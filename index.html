<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />









  <link rel="alternative" href="/atom.xml" title="woostundy" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.0.0" />



<link rel="canonical" href="http://woostundy.github.io/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.0" />



  



    <title> woostundy </title>
  </head>

  <body>
    <div class="container">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">woostundy</a>
</div>

<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
          </a>
        </li>
      
        
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
          </a>
        </li>
      
        
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            标签
          </a>
        </li>
      
        
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            分类
          </a>
        </li>
      
        
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            关于
          </a>
        </li>
      
      
    </ul>
  
</nav>

<div class="mobile-navbar">
  <div class="mobile-header">
    <div class="mobile-header-logo">
      <a href="/." class="logo">woostundy</a>
    </div>

    <div class="mobile-header-icon">
      <span></span>
      <span></span>
      <span></span>
    </div>
  </div>
  <nav class="mobile-menu">
    
      
      <a class="mobile-menu-item" href="/">
        首页
      </a>
    
      
      <a class="mobile-menu-item" href="/archives/">
        归档
      </a>
    
      
      <a class="mobile-menu-item" href="/tags">
        标签
      </a>
    
      
      <a class="mobile-menu-item" href="/categories">
        分类
      </a>
    
      
      <a class="mobile-menu-item" href="/about">
        关于
      </a>
    
  </nav>
</div>
      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/12/12/两个局域网怎么互连？一个简单解决方案/">两个局域网怎么互连？一个简单解决方案</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Dec 12, 2016
        </span>
      </div>
    </header>

    

    <div class="post-content">
      
        

        
          <p>背景故事这样的：工作室有两条宽带，一条用于同学们日常使用，另一条留给四台服务器专用，两个宽带分别用两个路由器做出口。</p>
<p>现在有几个同学想要远程连服务器，但不在一个内网很麻烦，如果都放在同一个网络，又不希望服务器专用网络的带宽被占用。</p>
<p>所以，问题就成了A, B两个局域网怎么在保证wlan出口不变的情况下，让A局域网内的部分机器能直接访问B局域网内的机器。</p>
<p>开始想过用VPN，但从外网绕进来，怎么也觉得别扭。后来又想俩路由器中间加个交换机，弄个trunk接口。</p>
<p>最后突然想明白，这不等同于一个局域网两个wlan口的问题嘛。<br>想明白这事，解决方案就很简单了：</p>
<ol>
<li>两个路由器A和B网线连lan口并联，把lan设置到同一IP段。</li>
<li>路由器A开DHCP（默认网关指向A本身就行），路由器B关闭DHCP。</li>
<li>其他同学日常用网用自动获取IP，网关自动就指向A。而服务器手动设置IP，网关指向路由器B。</li>
<li>这样就实现两个网络互通，且出口不同了。</li>
<li>最后在路由器A上添加访问规则，限制只能有部分同学的MAC地址可以访问服务器所在的IP范围。</li>
</ol>
<p>其实用一个双wlan口的路由器也能解决这个问题，只是后续再有变更可能没俩路由器那么灵活。<br>第三步如果服务器量大了手动设置就很麻烦，需要用静态DHCP+路由规则去做。</p>

        
      
    </div>

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/11/15/梁山神算子算天机-江州黄通判通地孤/">梁山神算子算天机 江州黄通判通地孤</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Nov 15, 2016
        </span>
      </div>
    </header>

    

    <div class="post-content">
      
        

        
          <p>话说当年宋江在江州浔阳楼题了反诗，被江州知府蔡九关押在死牢。蔡九依黄文炳之计，写家书给父亲蔡京，以炫耀“抓获反贼”之功，并让蔡京指点如何处置宋江。</p>
<p>岂料戴宗中途被朱贵药酒迷倒，被同家书一并递与梁山。晁天王听完宋江在牢中心急火燎，定是要带着头领们打入死牢解救宋江，军师吴用却阻拦道：哥哥莫急，此事不可力敌，只能智取—— 我等将计就计，写一封假回书，让戴院长带回去，书上只说教把犯人宋江解赴东京再处决示众，待他来此间经过我们夺了便是。</p>
<p>晁盖道：好是好，只是没人会蔡京笔迹，又没蔡京图章。吴用说有圣手书生萧让可写蔡京字迹，玉臂匠金大坚可刻图章。诸位好汉无不称妙之时，忽闻一声且慢，原来是神算子蒋敬，蒋敬上前道：军师且慢，请细看此家书封底。</p>
<p>众人凑近细看，发现有两行蝇头小字，上书“七四八六九零八八七二三一九三”，下书“四六七三二九七五三”。</p>
<p>晁盖吴用不解，问道：先生这是何意？</p>
<p>蒋敬道：此乃“数章”，用以验明书者正身，文未篡改。</p>
<p>吴用道：寥寥二十余字如何验得，还请先生赐教。</p>
<p>蒋敬在地上画道：此书有两百余字，取首字“今”，得其笔数为四，记于纸上，次字为“有”，其笔数为六，四六得二四，取第二四字，得其笔数为七，记于纸上，七再乘第二五字笔数，再记所的字笔数，若超总字数，则从首再计，如此往复九循，可得“散列”，又名“土法哈希”，若此数无异，可保文未篡改。</p>
<p>吴用叹服之余，又道：今先生既已得“土法哈希”之术，我等效之算出“散列”，书与家书封后，岂不万全？</p>
<p>蒋敬道：军师且听我言，这两行字上面是“数签”，下面则是“数密”。古人云，数若三，七，十三，十七，十九者，除以非一之数，皆无穷尽，谓曰“孤数”。蔡九藏一孤数，名天孤，蔡京写信前新取一孤数，名地孤。天孤乘地孤之积，为数密，又名“土法土法阿爱斯爱”。蔡京以地孤乘“散列”，可得“数签”，“数签”、“数密”记于家书封底，待蔡九收到时以“数密”除以天孤，可得地孤，以验“数签”，可知此书真假。蔡九回书，亦是如此。</p>
<p>晁盖忙道：如今我等既知“数密”，令梁山数百识得数的兄弟分头去算，不过半日，岂不得天孤地孤？</p>
<p>蒋敬叹气道：哥哥所不知啊，由天孤地孤得数密只需三个时辰，可要从数密得天地孤，用尽天下算筹算到黄天更替也不一定算出来啊。<br>晁盖林冲等一帮头领顿足叹气时，吴用道：我有一计，可破此“数签”，令鼓上骚时迁去蔡九府上，盗一封旧家书，假回书只要字数一致，关键字照用旧家书的字，其他内容遣词填补，更替语义，便可不知天地孤亦能造假。<br>晁盖蒋敬拍手称秒：军师不愧为智多星！当下吩咐首领们去做。</p>
<p>话说戴宗扣着日期，回了江州，当厅下了回书，蔡九见戴宗如期归来，好生欢喜，令下人算了地孤，验了数签，心里踏实了。过了两日，临要押送宋江出发时，门子来报“无为军黄通判前来特探”，蔡九将回书给黄文炳看了一番，黄文炳看行文古怪，心有疑虑，又亲自算了一遍地孤和数签。卷过来一看，又见封面新鲜，摇头道：这份回书是假的。</p>
<p>知府到：通判差矣，此是家尊亲笔手迹，又有数签可证，怎会是假的。<br>黄文炳道：我方才又算，得地孤是“六一五一九”，蔡权相府上选地孤，几月便选几开头的地孤，如今九月，此地回书必定是盗用旧文书伪造而成，此乃“时密不符“。</p>
<p>蔡九一惊，急忙唤回戴宗，盘问之下，戴宗不能对答。随即将戴宗一并打入死牢，等候处斩。</p>
<hr>
<p>注解</p>
<ul>
<li>数章：数字签名，数字签名通过摘要和加密算法来保证原文的真实性。文中的数字签名(数章)分成了两部分，第一行是加密后的摘要内容(数签)，第二行是加密采用的公钥(数密)。</li>
<li>土法哈希：Hash，散列函数。实际散列函数计算方式很复杂，文中所写的通过笔画和字的位置算摘要的方法非常简陋，只能保证确定性，却不具备唯一性，很容易出现散列冲突(或者叫哈希碰撞)，文中吴用在后面发现了这个特性，并利用哈希碰撞一定程度上破解了这个算法。我们常见的MD5和SHA1等都属于Hash算法，MD5和SHA实际上也存在哈希碰撞(Collision)的可能，王小云教授破解MD5正是利用了这个原理。</li>
<li>土法阿爱斯爱：RSA，目前最著名的非对称加密算法，RSA算法的核心是极大整数的因数分解和欧拉定律。文中的加密方法只是单纯的利用了大整数难以分解因数的特性，实际上RSA的计算过程和秘钥长度都复杂很多。</li>
<li>孤数：素数/质数，中国古代数学其实并没有素数这个概念。</li>
<li>天孤：用来当私钥的大素数。</li>
<li>地孤：用来实际和哈希值参与计算的素数。</li>
<li>时密不符：时间戳不匹配。在数字签名里加上时间戳可以防止重放攻击，保证信息的时效性。文中蔡京指定发信月份和素数首位匹配，能简单的保证信件时效性，也弥补了哈希算法过于简单导致的被碰撞的漏洞。黄文炳最终靠这一点发现了信件是伪造的。</li>
</ul>
<p>这篇故事新编是我几个月前某天晚上一时兴起发在朋友圈里的，换了种方式给大家科普加密算法。<br>但为了故事氛围和易于理解，将概念都简化了，到底还是戏说。各位有兴趣可以去网上再找资料进一步了解。</p>

        
      
    </div>

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/16/常见加密算法简介/">常见加密算法简介</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 16, 2016
        </span>
      </div>
    </header>

    

    <div class="post-content">
      
        

        
          <h2 id="一、对称加密_对称密钥（Symmetric-key_cryptography）">一、对称加密 对称密钥（Symmetric-key cryptography）</h2><hr>
<h3 id="概述">概述</h3><p>对称加密是指加解密用同一个密钥的算法，根据具体实现分为流加密和分组加密两种类型：</p>
<ul>
<li><p>流加密（Stream cipher）是对称加密常用的一种实现方法，加密和解密双方使用相同伪随机加密数据流，一般都是逐位异或随机密码本的内容。</p>
</li>
<li><p>分组加密加密（Block cipher），也叫块加密，将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。现代分组加密建立在迭代的思想上产生密文。迭代产生的密文在每一轮加密中使用不同的子密钥，而子密钥生成自原始密钥。</p>
</li>
</ul>
<p>对称加密普遍比非对称加密速度要快，实现更简单，适合大量内容的加密</p>
<h3 id="DES_(Data_Encryption_Standard)">DES (Data Encryption Standard)</h3><p>DES是一种分组加密算法</p>
<p>DES算法的入口参数有三个:Key,Data,Mode，Key是密钥密钥占7个字节56位（64位里另外8位是用来校验的），Data是加密内容，占8个字节64位，Mode是加密还是解密。</p>
<p>DES算法于1976被确定，现在已经被认为不够安全，主要原因是56位的密钥过短。据说这个算法因为包含一些机密设计元素，被怀疑内含美国国家安全局（NSA）的后门。</p>
<p>DES算法有个拓展算法叫3DES，就是对数据块进行三次DES加密，增加爆破成本，但本质上也不够安全。</p>
<h3 id="RC4_(Rivest_Cipher_4)">RC4 (Rivest Cipher 4)</h3><p>RC4是一种流加密算法</p>
<p>RC4起源于1987年，现在已经被认为不够安全。<br>RC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。S盒用来加密数据，而且在加密过程中S盒会变化。</p>
<p>由于异或运算的对合性，RC4加密解密使用同一套算法。这个算法实现起来很简单，只用了最基本的加、异或、循环，话说我大学时某个课程设计的做的加密算法就是简化版的RC4。</p>
<p>之后还出现了RC5、RC6加密算法，但RC5和RC6都是分组加密，和RC4原理并不一样。</p>
<h3 id="RC5（Rivest_Cipher_5）">RC5（Rivest Cipher 5）</h3><p>RC5是一种分组加密算法，它和RC2，RC4，RC6都是同一个叫Ronald Rivest的人设计的。</p>
<p>相比RC4，RC5的密钥成了128位，但RC5仍然只需要基础的加、异或、循环运算，可以在很多硬件上实现。RC5有三个参数：字的大小，循环轮数（round），密钥中的8位字节个数，所以可以说RC5是一种可变加密算法。实际上循环轮数12轮以下的RC5都被认为是不安全的，会被差分分析法（Differential cryptanalysis）攻击，18-20轮才足够安全。</p>
<p>目前来说，RC5还是挺安全的，因为实现简单，消耗资源少，在一些传感器、嵌入式设备上使用很合适。</p>
<h3 id="RC6（Rivest_Cipher_6）">RC6（Rivest Cipher 6）</h3><p>RC6是RC5的加强版，也属于分组加密算法。</p>
<p>RC6算法在RC5算法基础之上针对RC5算法中的漏洞，主要是循环移位的位移量并不取决于要移动次数的所有比特，通过采用引入乘法运算来决定循环移位次数的方法，对RC5算法进行了改进，从而大大提高了RC6算法的安全性。</p>
<p>RC6曾作为AES（高级加密标准）备选算法之一，但最终AES选择了Rijndael算法。</p>
<h3 id="AES_(Rijndael)">AES (Rijndael)</h3><p>最后压轴出场的是最著名的单密钥对称加密算法AES，AES是Advanced Encryption Standard的缩写，是美国国家标准与技术研究院2001年发布的新加密标准。<br>AES现在就是指的限定了区块长度和密钥长度的Rijndael算法，同样属于分组加密算法，该算法是两位比利时学者1998年发布的。起初还有很多算法参与了AES甄选，最终Rijndael凭借高安全性和清晰的数学结构而被选用。<br>AES将Rijndael算法的区块长度固定为128位，密钥长度可选128，192或256比特（Rijndael原版支持128-256，n*32的区块长度和密钥长度）。</p>
<p>AES算法包括4个步骤：</p>
<ol>
<li>AddRoundKey—矩阵中的每一个字节都与该次回合密钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。</li>
<li>SubBytes—通过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。</li>
<li>ShiftRows—将矩阵中的每个横列进行循环式移位。</li>
<li>MixColumns—为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略MixColumns步骤，而以另一个AddRoundKey替换。</li>
</ol>
<p>截止现在（2016），AES在算法层面上是安全的。2005年有人公布过一种缓存时序攻击法，但使用场景非常极端。</p>
<h3 id="未完_其他待补充">未完 其他待补充</h3><h2 id="二、非对称加密_公钥加密（Asymmetric_key_cryptography）">二、非对称加密 公钥加密（Asymmetric key cryptography）</h2><hr>
<h3 id="概述-1">概述</h3><p>公钥加密的思想于1974年被提出，相比对称加密无需共享密钥，更加安全。但是没法加密大量数据，一般用来加密对称加密的密钥，而用对称加密加密大量数据。<br>非对称加密的原理如下：</p>
<ol>
<li>消息发送方A在本地构建密钥对，公钥和私钥；</li>
<li>消息发送方A将产生的公钥发送给消息接收方B；</li>
<li>B向A发送数据时，通过公钥进行加密，A接收到数据后通过私钥进行解密，完成一次通信；</li>
<li>反之，A向B发送数据时，通过私钥对数据进行加密，B接收到数据后通过公钥进行解密。</li>
</ol>
<h3 id="RSA">RSA</h3><p>RSA算法是最著名的非对称加密算法。RSA是1977年提出的，名字来源于Rivest、Shmir和Adleman三位作者。<br>我们平时用到的SSL协议，TLS协议都采用了该算法加密，SSH（Secure Shell）也是基于RSA实现的。</p>
<p>RSA的数学基础是极大整数的因数分解，具体实现过程如下：</p>
<ol>
<li>随意选择两个大的质数p和q，p不等于q，计算N=pq。</li>
<li>根据欧拉函数，求得r=varphi (N) = varphi(p) * varphi(q)=(p-1)(q-1)</li>
<li>选择一个小于r的整数e，使e与r互质。并求得e关于r的模反元素，命名为d。</li>
<li>(N,e)是公钥，(N,d)是私钥。</li>
<li>加密时，加密的块 n^e ≡ c(MOD N)，得到的c就是密文。解密时，c^d ≡ n(MOD N)。</li>
</ol>
<p>要破解RSA要解决怎么把一个极大数分解为两个质数p和q，然后通过欧拉函数再得到公钥和私钥。但极大数因数分解目前还没什么好办法，所以只要N足够大，RSA在算法层面上就是安全的。</p>
<p>当N的长度为256时，用普通电脑花几小时即可以分解，当N长度为512时需要花数月时间分解，1024时需要大型分布式系统才能分解，长度到2046则可以确保是完全安全的。目前已有记录里，被分解的极大数最大位数是768位，于2009年被分解。</p>
<p>RSA也常被用来做数字签名，在消息内附加一个私钥加密过的散列值（Message digest），以此来确保消息发送人是可靠的。</p>
<h3 id="椭圆曲线算法（Elliptic_curve_cryptography）">椭圆曲线算法（Elliptic curve cryptography）</h3><p>椭圆曲线算法也是一种非对称加密算法，于1985年被提出，以下简称ECC。<br>相比RSA，同等破解难度时ECC的秘钥更短。另外，ECC可定义椭圆曲线群的双线性映射，该特性可能将来被用来实现身份基加密体制（Identity-Based Encryption，IBE）。</p>
<p>ECC的数学基础是求椭圆曲线离散对数问题。实现比较复杂我就不写了，因为我也看不懂(⊙﹏⊙)b。 也正因为实现复杂，ECC的加解密速度慢，消耗资源也更多。</p>
<p>ECC也同样可以实现数字签名，叫做ECDSA。</p>
<p>ECC的秘钥长度最小要求是160位，建议是163位。目前已有的破解记录是109位，一万台机器破解了一年半。所以ECC在算法层面是可以保证安全的。</p>
<h3 id="ElGamal">ElGamal</h3><p>ElGamal加密算法是一种用于对采用Diff-Hellman方式进行交换的公钥进行加密，常被用于数字签名和密钥加密的算法，ElGamal的数学基础是有限域上的离散对数问题。</p>
<p>选择一个素数p和两个随机数g 、x （g、 x &lt; p ），计算 y ≡ g^x（ mod p ） ，则其公钥为 y, g 和p ，私钥是x ，g和p可由一组用户共享。</p>
<p>ElGamal方法中一个明文对应两个加密结果(g^a和g^b)，因此密文空间的大小是明文空间大小的两倍，也就是说纵观整个通信过程，收发密文的大小是实际明文大小的两倍。</p>
<h3 id="待补充">待补充</h3><h2 id="三、哈希算法">三、哈希算法</h2><hr>
<h3 id="概述-2">概述</h3><p>我们经常说MD5加密，但追根究底的话，MD5应该是哈希函数（Hash Function），而哈希函数并不等同于加密（Encrypt），不过我们平常也把哈希叫做加密。哈希函数也叫散列函数，散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用来代表一个短的随机字母和数字组成的字符串。</p>
<p>说人话就是哈希（Hash）是将目标文本转换成具有相同长度的、不可逆的杂凑字符串，而加密（Encrypt）是将目标文本转换成具有不同长度的、可逆的密文。</p>
<p>哈希主要用来校验身份，错误检查，完整性检查。</p>
<h3 id="MD5（Message-Digest5_Algorithm）">MD5（Message-Digest5 Algorithm）</h3><p>MD5即消息摘要算法，是最著名、应用最为广泛的一种哈希算法，于1992年被公开。MD5之前还有MD4、MD3、MD2等哥哥算法，MD5是最终的改进版。<br>MD5输入不定长度信息，输出固定长度为128-bits的散列</p>
<h3 id="未完_待补充">未完 待补充</h3>
        
      
    </div>

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/15/Apache2自签发V3证书详细流程/">Apache2 设置自签发证书</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 15, 2016
        </span>
      </div>
    </header>

    

    <div class="post-content">
      
        

        
          <h2 id="1-_生成自建CA_Root">1. 生成自建CA Root</h2><h3 id="什么是CA">什么是CA</h3><p>CA,Catificate Authority，数字证书认证中心，用于签发证书，保证客户端之间服务端的信任。CA实际上是在做key和cert的pair。<br>常见的Symantec, Comodo等公司都是CA服务商。</p>
<h3 id="为什么要CA">为什么要CA</h3><p>不经过CA签证的证书之间挂到Apache上也能用，但浏览器肯定会报错ERR_CERT_AUTHORITY_INVALID，带着一个红叉，需要点强行访问来通过。使用这些公司签发的证书浏览器能自动识别，是因为浏览器已经内置了这些厂商的根证书。<br>我们自己做一个CA，一方面是可以去掉报错和红叉，另一方面也是为了实现双向认证模式。</p>
<h3 id="生成CA的key,CSR,Cert">生成CA的key,CSR,Cert</h3><p>待补充</p>
<h3 id="生成CSR，并由CA签发">生成CSR，并由CA签发</h3><p>待补充</p>
<h2 id="2-配置到Aapche2上">2.配置到Aapche2上</h2><p>1.将生成的证书和生成所用的key复制到目标服务器指定目录</p>
<p>2./etc/apache2/sites-available/default-ssl.conf<br>将<virtualhost _default_:443="">节点下修改为如下</virtualhost></p>
<pre><code>&lt;VirtualHost <span class="string">_default_:</span><span class="number">443</span>&gt;
ServerAdmin shitao<span class="annotation">@transfereasy</span>.com
ServerName localhost
DocumentRoot <span class="regexp">/var/</span>www/html
SSLEngine on
SSLCertificateFile      <span class="regexp">/etc/</span>apache2<span class="regexp">/ssl/</span>apache.crt
SSLCertificateKeyFile <span class="regexp">/etc/</span>apache2<span class="regexp">/ssl/</span>apache.key
</code></pre><p>3.确保打开ssl模块和default-ssl.conf文件，重启apache</p>
<pre><code><span class="title">sudo</span> a2enmod ssl
<span class="title">sudo</span> a2ensite <span class="default"><span class="keyword">default</span>-ssl.conf</span>
<span class="title">sudo</span> service apache2 restart
</code></pre><p>4.打开url强制跳转</p>
<pre><code><span class="keyword"><span class="common">RewriteEngine</span></span> <span class="literal">on</span>
<span class="keyword"><span class="common">RewriteCond</span></span> <span class="cbracket">%{SERVER_PORT}</span> !^443$
<span class="keyword"><span class="common">RewriteRule</span></span> ^/?(.*)$ https://<span class="cbracket">%{SERVER_NAME}</span>{REQUEST_URI}<span class="sqbracket"> [L,R]</span>
</code></pre>
        
      
    </div>

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/03/08/详解HTTP细节-1/">详解HTTP细节 1</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2016
        </span>
      </div>
    </header>

    

    <div class="post-content">
      
        

        
          <p>HTTP协议基于TCP/IP协议，属于无状态协议</p>
<h2 id="HTTP_0-9">HTTP 0.9</h2><p>样例：<br><code>GET 192.168.1.2/test.txt</code><br>GET开头，空格接着URL地址和查询字符串，CRLF换行结束，返回结果默认是HTML格式（如果不是服务器也没法通知），HTTP 0.9不支持一台服务器IP对应多个域名，属于已经过时的协议，<strong>但大部分浏览器仍然支持HTTP 0.9，这将导致一些安全问题</strong></p>
<h2 id="HTTP_1-0/1-1">HTTP 1.0/1.1</h2><p>请求样例：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="request">GET <span class="string">/myweb/login.jsp</span> HTTP/1.1</span></span><br><span class="line"><span class="attribute">Cookie</span>: <span class="string">JSESSIONID=77FC1A52E9C3BAD0536359386A96C0FB</span></span><br><span class="line"><span class="attribute">x-requested-with</span>: <span class="string">XMLHttpRequest</span></span><br><span class="line"><span class="attribute">Accept-Language</span>: <span class="string">zh-cn</span></span><br><span class="line"><span class="attribute">Referer</span>: <span class="string">https://192.168.0.0:8443//myweb/login.jsp</span></span><br><span class="line"><span class="attribute">Accept</span>: <span class="string">*/*</span></span><br><span class="line"><span class="attribute">Content-Type</span>: <span class="string">application/x-www-form-urlencoded;charset=UTF-8</span></span><br><span class="line"><span class="attribute">Host</span>: <span class="string">192.168.0.0:8443</span></span><br><span class="line"><span class="attribute">Connection</span>: <span class="string">Keep-Alive</span></span><br><span class="line"><span class="attribute">User-Agent</span>: <span class="string">Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Win64; x64; Trident/4.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; Tablet PC 2.0)</span></span><br></pre></td></tr></table></figure></p>
<p>第一行包含具体的版本信息，紧接着数条“名称：值”键值对组成的数据行（头域 Headers），每行为一个头域。请求头部分以一个单独的空行结束，空行后面可以加上需要发送给服务器的数据，这些数据长度必须在请求头Content-Length里明确标出。HTTP协议对后面部分数据的格式没有明确要求。<br>返回样例：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="status">HTTP/1.1 <span class="number">200</span> OK</span></span><br><span class="line"><span class="attribute">Server</span>: <span class="string">openresty</span></span><br><span class="line"><span class="attribute">Date</span>: <span class="string">Tue, 08 Mar 2016 08:24:48 GMT</span></span><br><span class="line"><span class="attribute">Content-Type</span>: <span class="string">text/html; charset=utf-8</span></span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: <span class="string">chunked</span></span><br><span class="line"><span class="attribute">Connection</span>: <span class="string">keep-alive</span></span><br><span class="line"></span><br><span class="line"><span class="nginx"><span class="title">Hello</span> world</span></span><br></pre></td></tr></table></figure></p>
<p>第一行包含协议版本和状态码以及状态信息描述（可选），随后若干响应数据行，以一个单独空行结束，再后面是返回的正文内容。<strong>实际情况里，状态码很不可靠</strong>，如果客户端请求里Accept-Encoding没有规定能接受的压缩方式，服务器端可以在gzip、compress、deflate三种压缩方式里任选一种传输。</p>
<h2 id="HTTP_1-0与1-1的差异">HTTP 1.0与1.1的差异</h2><ul>
<li>HTTP 1.1 加入了OPTIONS、PUT、DELETE、TRACE、CONNECT请求方法 （原有GET、POST、HEAD）</li>
<li>HTTP 1.1 增加数个头域<ul>
<li><strong>增加了HOST域，以应对同一IP的多个虚拟主机</strong>；</li>
<li>增加了Upgrade头域，用来告诉服务端，客户端能够支持的其它备用通信协议；</li>
<li>增加了Via头域，用来记录消息转发的路径，它记录了整个路径上所有发送方使用的版本号；</li>
<li>增加了Cache-Control头域（请求消息和响应消息都可使用），用来控制缓存；</li>
<li>增加Content-Range，用于节约优化。</li>
</ul>
</li>
<li>HTTP 1.1 增加了100、305等24个新状态码</li>
<li><strong>HTTP 1.0中需要建立长连接头域必须有Connection: Keep-Alive，HTTP 1.1 默认打开长连接，而且HTTP 1.0的Proxy不支持Connection头域，协议规定所有出现在Connection头域中的头域名都将被忽略。</strong></li>
<li>HTTP 1.1允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容</li>
<li><strong>HTTP 1.1 支持Transfer-Encoding:chunked</strong> 发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。<strong>这个差别有可能导致内容解析问题。</strong></li>
<li>HTTP/1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。</li>
<li>date/timestamp (日期时间戳)有细微差别。</li>
</ul>
<h2 id="关于RESTful">关于RESTful</h2><p>中间插一句，最近很流行的一个概念RESTful，REST全称是Representational State Transfer，不过这个全称看着也很懵逼。提出这个概念的Roy Thomas Fielding是HTTP协议的主要设计者，以我的理解，REST其实是让我们回归HTTP方法本身的语义。</p>
<p>HTTP 1.1 是1999年发表的，HTTP 2都发布了，但开发者几乎还在用HTTP 1.0的特性，请求方法平时几乎只用到GET和POST，大量的GET方法都不是幂等的。这显然有悖于HTTP 1.1的设计思想。</p>
<p>REST作为一种标准或者约定，主要定义了以下几点：</p>
<ul>
<li>URL定位资源，URL都指向Resource，都应该是名词，不涉及任何操作语义</li>
<li><p>操作语义交给HTTP请求方法，GET和PUT应当幂等：</p>
<ul>
<li>GET 获取资源，</li>
<li>POST 新建资源</li>
<li>PUT 更新资源，</li>
<li>DELETE 删除资源</li>
<li>UPDATE 更新资源</li>
</ul>
<p>如上，其实HTTP协议的请求方法已经能覆盖所有对资源的操作了。</p>
</li>
<li>HTTP传递资源（无论Json、XML还是二进制数据，都是资源的不同形式）</li>
<li>使用正确的HTTP状态码。HTTP 1.1就有三十多个状态码了。但我们平时用到的极少，很多网站都只有404、500、200这三个状态码。</li>
<li>用/嵌套的url来标示子资源，比如：/tickets/12/messages</li>
<li>用?来过滤资源</li>
</ul>
<p>以上这些约定，仔细看不难发现，都是在重复和强调HTTP本身的语义。</p>
<h2 id="安全问题">安全问题</h2>
        
      
    </div>

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/03/04/详解URL细节/">详解URL细节</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 4, 2016
        </span>
      </div>
    </header>

    

    <div class="post-content">
      
        

        
          <h2 id="URL标准结构">URL标准结构</h2><blockquote>
<p>scheme://login:password@address:port/path/to/resource?query_string#fragment</p>
</blockquote>
<ol>
<li>scheme 协议名称<ul>
<li>协议名称由一串不分大小写的字符串组成，以单个冒号结束。</li>
<li>官方认可的有效URL协议由IANA维护，包括http:、https:、ftp:等十余种，但常见浏览器也支持其他伪协议，如data:、javascript:。</li>
<li>浏览器在做进一步解析前，会先判断URL是相对URL还是绝对URL，相对URL要根据当前浏览的上下文才能判断完整的URL。最关键的区别就在于，URL最前面是否包含有效的协议名称。</li>
<li>按照RFC1738规定，URL在冒号之前只允许出现数字字母及”+”,”-“,”.”这三个符合，但实际应用环境中，<strong>所有主流浏览器都会忽略前导换行符和空格</strong>。IE还会忽略所有不可打印字符（ASCII 0x01~0x1F），Chrome会忽略0x00和NUL空字符，Opera协议名里可以包含高位字符。</li>
</ul>
</li>
<li>// 层级标记符 <ul>
<li>RFC1738规定，每个层级结构URL里都必须包含//层级标记符，实际应用环境里各个浏览器表现不同。</li>
<li>http:example/ 在FireFox、Chrome、Safari里直接输入这个URL是可以正常解析的，等同与<a href="http://example/，但有基准URL时，这会被认为是指向example目录的相对路径。" target="_blank" rel="external">http://example/，但有基准URL时，这会被认为是指向example目录的相对路径。</a></li>
<li>javascript://example.com/%0alert(1) 所有浏览器都会认为这个字符串是有效的非层级伪URL，忽略前面的部分并直接执行Js。</li>
<li>mailto://user@example.com IE会忽略层级标记符，直接指向电子邮件地址，其他浏览器不能解析。</li>
<li>IE可以使用\\代替//。</li>
</ul>
</li>
<li>login:password 身份验证<ul>
<li>URL身份验证属于可选项，身份验证信息的传输和协议有关，FTP等部分协议有效，HTTP等协议里如果强行加入这部分信息，没有明确规定怎么处理。</li>
<li>大部分浏览器在身份验证部分里不接受数字字母外的几乎任何字符。</li>
</ul>
</li>
<li>address 服务器地址<ul>
<li>RFC允许不区分大小的域名（example.com），IPv4地址（192.168.1.1），一对方括号里的IPv6地址（[0:0:0:0:0:0:0:1]），FireFox支持方括号里的IPv4地址和主机名，其他浏览器不允许。</li>
<li>实际环境里，浏览器接受八进制、十进制、十六进制，甚至多字节专程单个整数的写法（和浏览器锁依赖的标准C类库有关）。</li>
<li>大部分浏览器会忽略出现在URL内的 0x0A~0x0D、0xA0~0xAD之间的控制字符，而且会主动的把主机名里的全角句号”。”转为”.”（只是主机名，在其他部分则不会转换）</li>
</ul>
</li>
<li>port 服务器端口</li>
</ol>
<ul>
<li>在服务器连接的网络端口并非标准端口时会用到，UDP和TCP都依赖一个16位的端口号来区分不同服务。</li>
<li>我们可以用浏览器想任意服务器发送数据，<strong>即便浏览器不支持这些服务的协议</strong>，比如SMTP。</li>
</ul>
<ol>
<li>path to resource 层级文件路径</li>
</ol>
<ul>
<li>层级文件路径借鉴自UNIX目录语义，支持”/../“和”/./“。</li>
<li>现在的Web应用层级文件路径大多和实际物理路径没什么联系了。</li>
</ul>
<ol>
<li>query_string 查询字符串 </li>
</ol>
<ul>
<li>常见格式为 name1=value1&amp;name2=value2… 但RFC实际上没有规定必须用这种格式，所以也允许query_string是一堆乱七八糟 的字符串，关键在于接受后怎么处理。</li>
</ul>
<ol>
<li>fragment 片段ID</li>
</ol>
<ul>
<li>fragment和查询字符串有点类似，但它是用于客户端的一种可选信息，RFC里没有明确规定片段ID的功能和格式。</li>
<li>实际运用里，片段ID在浏览器中只有一个用途：指向HTML页面的某个锚点。</li>
<li>与query_string不同的是，改变fragment不会触发页面重载，也没有时间开销，所以可以用来存储一些客户端相关的数据。</li>
</ul>
<h2 id="浏览器解析步骤">浏览器解析步骤</h2><ol>
<li>提取协议名称：查找第一个”：”，该字符左边的部分就是协议名称，如果协议名称里出现了不该有的字符，则该URL就是相对URL，这部分内容也不会当成协议处理。</li>
<li>去除层级标记符：如果有”//“就跳过，如果没有……那就不管了。在实际环境里，不用斜杠用一个用两个用三个其实都可以正常解析。</li>
<li>获取授权部分信息（登录信息+地址+端口）：依次查找“/”、“？”、“#”，哪个先出现以哪个为准截取，除了IE和Safari，分号；也是可接受的分隔符。</li>
</ol>
<ul>
<li>授权部分信息提取出来后，先查找@符号，如果找到了，那它前面的部分就是登录信息，冒号前面是用户名，后面是密码</li>
<li>剩下部分就是地址了，查找冒号：，如果有则前面的部分是地址，后面部分是端口，如果发现方括号[]，说明地址是IPv6</li>
</ul>
<ol>
<li>确定路径</li>
<li>提取查询字符串</li>
<li>提取片段ID</li>
</ol>
<h2 id="陷阱和问题">陷阱和问题</h2><ol>
<li><a href="http://example.com&amp;gibberish=1234@167772161/" target="_blank" rel="external">http://example.com&amp;gibberish=1234@167772161/</a><br>这个地址实际上指向的是167772161，转成正常的IPv4地址是10.0.0.1，@前面的部分是无效身份验证信息。</li>
<li><a href="http://example.com\@coredump.cx/" target="_blank" rel="external">http://example.com\@coredump.cx/</a><br>在FireFox里会访问coredump.cx，而其他浏览器里会访问example.com。</li>
<li><a href="http://example.com;.coredump.cx/" target="_blank" rel="external">http://example.com;.coredump.cx/</a><br>IE会访问coredump.cx，而其他浏览器会访问example.com。</li>
</ol>

        
      
    </div>

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/02/24/Some Tips/">Some Tips</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Feb 24, 2016
        </span>
      </div>
    </header>

    

    <div class="post-content">
      
        

        
          <ul>
<li>超过100人的公司，用键盘走位密码跑一遍，总会有收获。</li>
<li>Fishing内容：招聘——投递简历 科研——会议邀请 媒体——策划方案 销售——咨询产品 网站——错误反馈</li>
</ul>

        
      
    </div>

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2015/10/22/PowerShell XML处理、注册表Default取值坑两则/">PowerShell XML处理和注册表(Default)取值 坑两则</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Oct 22, 2015
        </span>
      </div>
    </header>

    

    <div class="post-content">
      
        

        
          <ol>
<li><p>处理XML时，PowerShell支持直接以对象的方式访问节点，像这样</p>
<pre><code>&lt;report&gt;
<span class="code">    &lt;baseInfo&gt;</span>
<span class="code">        &lt;systemLanguage&gt;zh-CN&lt;/systemLanguage&gt;</span>
<span class="code">    &lt;/baseInfo&gt;</span>
<span class="code">    &lt;error&gt;</span>
<span class="code">    &lt;/error&gt;</span>
&lt;/report&gt;

PS C:\Users\Woody&gt; $xmlObj.report.baseInfo

<span class="header">systemLanguage
--------------</span>
zh-CN
</code></pre></li>
</ol>
<p>但如果目标节点是没有子级，这样取到的节点类型不是xmlnode，而是object，如下所示。</p>
<pre><code>PS C:\Users\Woody&gt; <span class="variable">$test</span><span class="class">.report</span><span class="class">.baseInfo</span><span class="class">.systemlanguage</span><span class="class">.getType</span>()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                                   System<span class="class">.Object</span>


PS C:\Users\Woody&gt; <span class="variable">$test</span><span class="class">.report</span><span class="class">.baseInfo</span><span class="class">.getType</span>()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     False    XmlElement                               System<span class="class">.Xml</span><span class="class">.XmlLinkedNode</span>
</code></pre><p>所以，如果想给一个空的节点添加子节点就不能这样写，因为没有对应方法，应该用selectNodes代替，如下所示。</p>
<pre><code>PS <span class="keyword">C</span>:\Users\Woody&gt; $test.report.selectnodes(<span class="string">"error"</span>).item(<span class="number">0</span>).gettype()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
<span class="keyword">True</span>     <span class="keyword">False</span>    XmlElement                               System.Xml.XmlLinkedNode


PS <span class="keyword">C</span>:\Users\Woody&gt; $test.report.error.gettype()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
<span class="keyword">True</span>     <span class="keyword">True</span>     <span class="keyword">String</span>                                   System.Object


PS <span class="keyword">C</span>:\Users\Woody&gt; $test.report.error.appendChild
##没反应，表示不存在##
PS <span class="keyword">C</span>:\Users\Woody&gt; $test.report.selectnodes(<span class="string">"error"</span>).item(<span class="number">0</span>).appendChild


MemberType          : <span class="keyword">Method</span>
OverloadDefinitions : <span class="list">{System.Xml.XmlNode AppendChild(System.Xml.XmlNode newChild)}</span>
TypeNameOfValue     : System.Management.Automation.PSMethod
<span class="keyword">Value</span>               : System.Xml.XmlNode AppendChild(System.Xml.XmlNode newChild)
Name                : AppendChild
IsInstance          : <span class="keyword">True</span>
</code></pre><ol>
<li>注册表里有些键比较特殊，它里面包含一个Default项，如下图所示。如果想用PowerShell取这个值，要格外注意，<strong>PowerShell自带的注册表访问方法是没法访问到这个值的，这是个Bug，</strong> 我试了无数种访问方法，都不行，目测是（默认）和 (Default)这俩键值造成的冲突。</li>
</ol>
<p><img src="http://7xlizz.com1.z0.glb.clouddn.com/注册表.png" alt=""><br><img src="http://7xlizz.com1.z0.glb.clouddn.com/注册表操作.png" alt=""></p>
<p>解决办法只能是改用CMD的方式，用reg命令解决，如下所示。</p>
<pre><code>reg Query HKLM<span class="command">\System</span><span class="command">\CurrentControlSet</span><span class="command">\Control</span><span class="command">\Nls</span><span class="command">\Locale</span><span class="command">\ </span>/v "(Default)"
</code></pre><p>注意要先括号再引号</p>

        
      
    </div>

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2015/10/22/PowerShell-判断操作系统语言等信息/">PowerShell 判断操作系统语言</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Oct 22, 2015
        </span>
      </div>
    </header>

    

    <div class="post-content">
      
        

        
          <p>###用PowerShell判断系统语言的的几种方法：</p>
<ol>
<li>systeminfo.exe<br>最简单的方法，但是数据不好进一步处理，而且速度慢</li>
<li><p>WMI对象</p>
<pre><code>(<span class="keyword">get</span>-wmiobject win32_operatingsystem).MUILanguages
</code></pre></li>
<li><p>用.net对象获取，结果更加完整</p>
<pre><code><span class="comment">PS</span> <span class="comment">C:\Users\Woody</span>&gt; <span class="title">[</span><span class="comment">System</span><span class="string">.</span><span class="comment">Globalization</span><span class="string">.</span><span class="comment">Cultureinfo</span><span class="title">]</span><span class="comment">::InstalledUICulture</span>

<span class="comment">LCID</span>             <span class="comment">Name</span>             <span class="comment">DisplayName</span>
<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>             <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>             <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
<span class="comment">2052</span>             <span class="comment">zh</span><span class="literal">-</span><span class="comment">CN</span>            <span class="comment">中文(中华人民共和国)、</span>
</code></pre></li>
</ol>
<ol>
<li>读注册表键值</li>
</ol>
<pre><code><span class="keyword">function</span> getSysLangurage(){
   <span class="variable">$langNum</span> = reg Query HKLM\System\CurrentControlSet\Control\Nls\Locale\ /v <span class="string">"(Default)"</span>
   if(<span class="variable">$langNum</span> -like <span class="string">"*00000804"</span>){
   return <span class="string">"CH"</span>
   }
   elseif(<span class="variable">$langNum</span> -like <span class="string">"*00000409"</span>){
   return <span class="string">"EN"</span>
   }
   else
   {return <span class="string">"other"</span>}
}
</code></pre>
        
      
    </div>

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2015/10/20/PowerShell入门系列3基本语法/">PowerShell入门系列3基本语法</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Oct 20, 2015
        </span>
      </div>
    </header>

    

    <div class="post-content">
      
        

        
          
        
      
    </div>

    
  </article>

    
  </section>

  
  <nav class="pagination">
    
    
      <a class="next" href="/page/2/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          
        </div>  
      </main>

      <footer id="footer" class="footer">
  <div class="social-links">
    
      
        
          <a href="mailto:woostundy@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="http://www.weibo.com/woostundy" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
        
          <a href="http://www.zhihu.com/people/shitao" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author"></span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    


  <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>

    <script type="text/javascript" src="/js/src/even.js?v=2.0.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.0.0"></script>

  </body>
</html>